<!DOCTYPE html>
<!-- saved from url=(0066)https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="never">
    <meta property="og:description" content="《FreeType Glyph Conventions》中译版FreeType字形约定一、基本印刷概念1、字体文件、格式和信息字体是一组可以被显示和打印的多样的字符映像，在单个字体中共享一些共有的特性">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>FreeType2中文手册 - htc开发 - 博客园</title>
    
    <link rel="stylesheet" href="./FreeType2中文手册_files/blog-common.min.css">
    <link id="MainCss" rel="stylesheet" href="./FreeType2中文手册_files/bundle-minyx2_lite.min.css">
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./FreeType2中文手册_files/bundle-minyx2_lite-mobile.min.css">
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/htc-javaMe/rss">
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/htc-javaMe/rsd.xml">
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/htc-javaMe/wlwmanifest.xml">
    <script async="" src="./FreeType2中文手册_files/analytics.js.下载"></script><script src="./FreeType2中文手册_files/jquery-2.2.0.min.js.下载"></script>
    <script src="./FreeType2中文手册_files/blog-common.min.js.下载"></script>
    <script>
        var currentBlogId = 120909;
        var currentBlogApp = 'htc-javaMe';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'Minyx2_Lite';
    </script>
    
    
    <script src="./FreeType2中文手册_files/bundle-minyx2_lite.min.js.下载" type="text/javascript" language="javascript"></script>
<link rel="preload" href="./FreeType2中文手册_files/f.txt" as="script"><script type="text/javascript" src="./FreeType2中文手册_files/f.txt"></script><script src="./FreeType2中文手册_files/pubads_impl_2020051801.js.下载" async=""></script><link rel="prefetch" href="https://410599fb7c7606b50ad34f02a480c6e1.safeframe.googlesyndication.com/safeframe/1-0-37/html/container.html"><link rel="prefetch" href="https://tpc.googlesyndication.com/safeframe/1-0-37/html/container.html"></head>
<body>
    <a name="top"></a>
    <div id="page_begin_html"><script type="text/javascript">window['__document_write_ajax_callbacks__']['3']();</script><script type="text/javascript">window['__document_write_ajax_callbacks__']['1']();</script>
<div style="display: none" id="__document_write_ajax_div-2"></div><script type="text/javascript" defer="">window['__document_write_ajax_callbacks__']['2']();</script></div>
    
<div id="container">
    <a class="minyx" href="https://www.cnblogs.com/">代码改变世界</a>
    <ul id="topMnu">
        <!-- 统计数据 -->
        <li>
            Posts - 
528, 
Articles - 
0, 
Comments - 
4
<!---->


        </li>
        <!-- 这边可以增加一些链接 -->
        <!-- 博客园 -->
        <li><a href="https://www.cnblogs.com/">Cnblogs</a></li>
        <!-- 管理 -->
        <li id="topMnu-dashboard">
            <a id="lnkDashboard" href="https://i.cnblogs.com/">Dashboard</a>
        </li>
        <li>
            
    <a id="lnkLogin" href="https://account.cnblogs.com/signin/?returnUrl=https://www.cnblogs.com/htc-javaMe/">Login</a>


        </li>
    </ul>

    <script type="text/javascript">
        var m = window.__blog.topMenuRendered;
        if (m) { m(__$("topMnu")); }
    </script>

    <div id="header">
        <ul id="menu">
            <!-- 首页，当前section加上current类 -->
            <li id="menu-home" class="current">
                <a id="lnkHome" href="https://www.cnblogs.com/htc-javaMe/">Home</a></li>
            <!-- 联系 -->
            <li id="menu-contact">
                <a id="lnkContact" href="https://msg.cnblogs.com/send/htc%E5%BC%80%E5%8F%91">Contact</a></li>
            <!-- 相册 -->
            <li id="menu-gallary">
                <a id="lnkGallery" href="https://www.cnblogs.com/htc-javaMe/gallery.html">Gallery</a></li>
            <!-- 订阅 -->
            <li id="menu-subscribe">
                <a id="blog_nav_rss" href="javascript:void(0);" data-rss="https://www.cnblogs.com/htc-javaMe/rss/">Subscribe</a></li>
            <!-- Rss订阅 -->
            <li id="rss">
                <a id="lnkRss" href="https://www.cnblogs.com/htc-javaMe/rss/">RSS</a></li>
        </ul>
        <div id="newmsg"></div>
        <h1>
            <!-- 主标题 -->
            <a id="lnkBlogTitle" href="https://www.cnblogs.com/htc-javaMe/">htc开发</a>
            <!-- 子标题 -->
            <small>
                
            </small>
        </h1>
    </div>

    <script type="text/javascript">
        var m = window.__blog.headerRendered;
        if (m) { m(__$("header")); }
    </script>

    <div id="wrapper">
        <div id="content">
            <script type="text/javascript">
                var m = window.__blog.preRenderPosts;
                if (m) { m(); }
            </script>
            <div id="post_detail">
<div class="post" id="post">
    <a name="top"></a>
    <h2>
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html">FreeType2中文手册</a>
</h2>
    <small>
<span id="post-date">2010-12-12 22:18</span>&nbsp;
<a href="https://www.cnblogs.com/htc-javaMe/">htc开发</a>&nbsp;
阅读(<span id="post_view_count">2955</span>)&nbsp;
评论(<span id="post_comment_count">1</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=2562529" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(2562529);return false;">收藏</a></small>
    <div class="entry">
        
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>
</p><table border="0">
<tbody>
<tr>
<td><span>《FreeType Glyph Conventions》中译版&nbsp;<br><br>FreeType字形约定&nbsp;<br><br>一、基本印刷概念&nbsp;<br>1、字体文件、格式和信息&nbsp;<br>字体是一组可以被显示和打印的多样的字符映像，在单个字体中共享一些共有的特性，包括外表、风格、衬线等。按印刷领域的说法，它必须区别一个字体 家族和多种字体外观，后者通常是从同样的模板而来，但是风格不同。例如，Palatino Regular 和 Palatino Italic是两种不同的外观，但是属于同样的家族Palatino。&nbsp;<br><br>单个字体术语根据上下文既可以指家族也可指外观。例如，大多文字处理器的用户用字体指不同的字体家族，然而，大多这些家族根据它们的格式会通过多 个数据文件实现。对于 TrueType来讲，通常是每个外观一个文件（arial.ttf对应Arial Regular外观，ariali.ttf对应Arial Italic外观）这个文件也叫字体，但是实际上只是一个字体外观。&nbsp;<br><br>数字字体是一个可以包含一个和多个字体外观的数据文件，它们每个都包含字符映像、字符度量，以及其他各种有关文本布局和特定字符编码的重要信息。 对有些难用的格式，像Adobe的Type1，一个字体外观由几个文件描述（一个包含字符映象，一个包含字符度量等）。在这里我们忽略这种情况，只考虑一 个外观一个文件的情况，不过在FT2.0中，能够处理多文件字体。&nbsp;<br><br>为了方便说明，一个包含多个外观的字体文件我们叫做字体集合，这种情况不多见，但是多数亚洲字体都是如此，它们会包含两种或多种表现形式的映像，例如横向和纵向布局。&nbsp;<br><br>2、字符映象和图&nbsp;<br>字符映象叫做字形，根据书写、用法和上下文，单个字符能够有多个不同的映象，即多个字形。多个字符也可以有一个字形（例如Roman？？）。字符 和字形之间的关系可能是非常复杂，本文不多述。而且，多数字体格式都使用不太难用的方案存储和访问字形。为了清晰的原因，当说明FT时，保持下面的观念&nbsp;<br><br>* 一个字体文件包含一组字形，每个字形可以存成位图、向量表示或其他结构（更可缩放的格式使用一种数学表示和控制数据/程序的结合方式）。这些字形可以以任意顺序存在字体文件中，通常通过一个简单的字形索引访问。&nbsp;<br><br>* 字体文件包含一个或多个表，叫做字符图，用来为某种字符编码将字符码转换成字形索引，例如ASCII、Unicode、Big5等等。单个字体文件可能包 含多个字符图，例如大多TrueType字体文件都会包含一个Apple特定的字符图和Unicode字符图，使它在Mac和Windows平台都可以使 用。&nbsp;<br><br>3、字符和字体度量&nbsp;<br>每个字符映象都关联多种度量，被用来在渲染文本时，描述如何放置和管理它们。在后面会有详述，它们和字形位置、光标步进和文本布局有关。它们在渲染一个文本串时计算文本流时非常重要。&nbsp;<br><br>每个可缩放的字体格式也包含一些全局的度量，用概念单位表示，描述同一种外观的所有字形的一些特性，例如最大字形外框，字体的上行字符、下行字符和文本高度等。&nbsp;<br><br>虽然这些度量也会存在于一些不可缩放格式，但它们只应用于一组指定字符维度和分辨率，并且通常用象素表示。&nbsp;<br><br><br>二、字形轮廓&nbsp;<br>1、象素、点和设备解析度&nbsp;<br>当处理计算机图形程序时，指定象素的物理尺寸不是正方的。通常，输出设备是屏幕或打印机，在水平和垂直方向都有多种分辨率，当渲染文本是要注意这些情况。&nbsp;<br><br>定义设备的分辨率通常使用用dpi（每英寸点(dot)数）表示的两个数，例如，一个打印机的分辨率为300x600dpi表示在水平方向，每英 寸有300 个象素，在垂直方向有600个象素。一个典型的计算机显示器根据它的大小，分辨率不同（15’’和17’’显示器对640x480象素大小不同），当然图 形模式分辨率也不一样。&nbsp;<br><br>所以，文本的大小通常用点（point）表示，而不是用设备特定的象素。点是一种简单的物理单位，在数字印刷中，一点等于1/72英寸。例如，大多罗马书籍使用10到14点大小印刷文字内容。&nbsp;<br><br>可以用点数大小来计算象素数，公式如下：&nbsp;<br><br>象素数 = 点数*分辨率/72&nbsp;<br><br>分辨率用dpi表示，因为水平和垂直分辨率可以不同，单个点数通常定义不同象素文本宽度和高度。&nbsp;<br><br>2、向量表示&nbsp;<br>字体轮廓的源格式是一组封闭的路径，叫做轮廓线。每个轮廓线划定字形的外部或内部区域，它们可以是线段或是Bezier曲线。&nbsp;<br><br>曲线通过控制点定义，根据字体格式，可以是二次(conic Beziers)或三次(cubic Beziers)多项式。在文献中，conic Bezier通常称为quadratic Beziers。因此，轮廓中每个点都有一个标志表示它的类型是一般还是控制点，缩放这些点将缩放整个轮廓。&nbsp;<br><br>每个字形最初的轮廓点放置在一个不可分割单元的网格中，点通常在字体文件中以16位整型网格坐标存储，网格的原点在(0,0)，它的范围是-16384到-16383（虽然有的格式如Type1使用浮点型，但为简便起见，我们约定用整型分析）。&nbsp;<br><br>网格的方向和传统数学二维平面一致，x轴从左到右，y轴从下到上。&nbsp;<br><br>在创建字形轮廓时，一个字体设计者使用一个假想的正方形，叫做EM正方形。他可以想象成一个画字符的平面。正方形的大小，即它边长的网格单元是很重要的，原因是&nbsp;<br><br>* 它是用来将轮廓缩放到指定文本尺寸的参考，例如在300x300dpi中的12pt大小对应12*300/72=50象素。从网格单元缩放到象素可以使用下面的公式&nbsp;<br><br>象素数 ＝ 点数 × 分辨率/72&nbsp;<br>象素坐标＝ 网格坐标*象素数/EM大小&nbsp;<br><br>* EM尺寸越大，可以达到更大的分辨率，例如一个极端的例子，一个4单元的EM，只有25个点位置，显然不够，通常TrueType字体之用2048单元的EM；Type1 PostScript字体有一个固定1000网格单元的EM，但是点坐标可以用浮点值表示。&nbsp;<br><br>注意，字形可以自由超出EM正方形。网格单元通常交错字体单元或EM单元。上边的象素数并不是指实际字符的大小，而是EM正方形显示的大小，所以不同字体，虽然同样大小，但是它们的高度可能不同。&nbsp;<br><br>3、Hinting和位图渲染&nbsp;<br>存储在一个字体文件中的轮廓叫“主”轮廓，它的点坐标用字体单元表示，在它被转换成一个位图时，它必须缩放至指定大小。这通过一个简单的转换完成，但是总会产生一些不想要的副作用，例如像字母E和H，它们主干的宽度和高度会不相同。&nbsp;<br><br>所以，优秀的字形渲染过程在缩放“点”是，需要通过一个网格对齐(grid-fitting)的操作（通常叫hinting），将它们对齐到目标 设备的象素网格。这主要目的之一是为了确保整个字体中，重要的宽度和高度能够一致。例如对于字符I和T来说，它们那个垂直笔划要保持同样象素宽度。另外， 它的目的还有管理如stem和overshoot的特性，这在小象素字体会引起一些问题。&nbsp;<br><br>有若干种方式来处理网格对齐，多数可缩放格式中，每种字形轮廓都有一些控制数据和程序。&nbsp;<br><br>* 显式网格对齐&nbsp;<br><br>TrueType格式定义了一个基于栈的虚拟机（VM），可以借助多于200中操作码（大多是几何操作）来编写程序，每个字形都由一个轮廓和一个控制程序组成，后者可以处理实际的网格对齐，他由字体设计者定义。&nbsp;<br><br>* 隐式网格对齐（也叫hinting）&nbsp;<br><br>Type1格式有一个更简单的方式，每个字形由一个轮廓以及若干叫hints的片断组成，后者用来描述字形的某些重要特性，例如主干的存在、某些宽度匀称性等诸如此类。没有多少种hint，要看渲染器如何解释hint来产生一个对齐的轮廓。&nbsp;<br><br>* 自动网格对齐&nbsp;<br><br>有些格式很简单，没有包括控制信息，将字体度量如步进、宽度和高度分开。要靠渲染器来猜测轮廓的一些特性来实现得体的网格对齐。&nbsp;<br><br>下面总结了每种方案的优点和缺点&nbsp;<br><br>方案	 优点	 缺点&nbsp;<br><br>显式	质量：对小字体有很好的结果，这对屏幕显示非常重要。	速度：如果程序很复杂，解释字节码很慢&nbsp;<br>一致性：所有渲染器产生同样的字形位图。	 大小：字形程序会很长。&nbsp;<br>技术难度：编写优秀的hinting程序非常难，没有好的工具支持。&nbsp;<br><br>隐式	大小：Hint通常比显式字形程序小的多	 质量：小字体不好，最后结合反走样&nbsp;<br>速度：网格对齐会非常快	 不一致：不同渲染器结果不同，甚至同一引擎不同版本也不同。&nbsp;<br><br>自动	大小：不需要控制信息，导致更小的字体文件	 质量：小字体不好，最后结合反走样&nbsp;<br>速度：依赖对齐算法，通常比显式对齐快。	 速度：依赖算法&nbsp;<br>不一致：不同渲染器结果不同，甚至同一引擎不同版本也不同。&nbsp;<br><br><br>三、字形度量&nbsp;<br>1、基线(baseline)、笔(pen)和布局(layout)&nbsp;<br>基线是一个假想的线，用来在渲染文本时知道字形，它可以是水平（如Roman）和是垂直的（如中文）。而且，为了渲染文本，在基线上有一个虚拟的点，叫做笔位置（pen position）或原点（origin），他用来定位字形。&nbsp;<br><br>每种布局使用不同的规约来放置字形：&nbsp;<br><br>* 对水平布局，字形简单地搁在基线上，通过增加笔位置来渲染文本，既可以向右也可以向左增加。&nbsp;<br><br>两个相邻笔位置之间的距离是根据字形不同的，叫做步进宽度（advance width）。注意这个值总是正数，即使是从右往左的方向排列字符，如Arabic。这和文本渲染的方式有些不同。&nbsp;<br><br>笔位置总是放置在基线上。&nbsp;<br><br><br>* 对垂直布局，字形在基线上居中放置：&nbsp;<br><br><br>2、印刷度量和边界框&nbsp;<br>在指定字体中，定义了多种外观度量。&nbsp;<br><br>* 上行高度（ascent）。从基线到放置轮廓点最高/上的网格坐标，因为Y轴方向是向上的，所以它是一个正值。&nbsp;<br><br>* 下行高度（descent）。从基线到放置轮廓点最低/下的网格坐标，因为Y轴方向是向上的，所以它是一个负值。&nbsp;<br><br>* 行距（linegap）。两行文本间必须的距离，基线到基线的距离应该计算成&nbsp;<br><br>上行高度 － 下行高度 ＋ 行距&nbsp;<br><br>* 边界框（bounding box，bbox）。这是一个假想的框子，他尽可能紧密的装入字形。通过四个值来表示，叫做xMin、yMin、xMax、yMax，对任何轮廓都可以计 算，它们可以是字体单元（测量原始轮廓）或者整型象素单元（测量已缩放的轮廓）。注意，如果不是为了网格对齐，你无需知道这个框子的这个值，只需知道它的 大小即可。但为了正确渲染一个对齐的字形，需要保存每个字形在基线上转换、放置的重要对齐。&nbsp;<br><br>* 内部leading。这个概念从传统印刷业而来，他表示字形出了EM正方形空间数量，通常计算如下&nbsp;<br><br>internal leading = ascent – descent – EM_size&nbsp;<br><br>* 外部leading。行距的别名。&nbsp;<br><br>3、跨距（bearing）和步进&nbsp;<br>每个字形都有叫跨距和步进的距离，它们的定义是常量，但是它们的值依赖布局，同样的字形可以用来渲染横向或纵向文字。&nbsp;<br><br>* 左跨距或bearingX。从当前笔位置到字形左bbox边界的水平距离，对水平布局是正数，对垂直布局大多是负值。&nbsp;<br><br>* 上跨距或bearingY。从基线到bbox上边界的垂直距离，对水平布局是正值，对垂直布局是负值。&nbsp;<br><br>* 步进宽度或advanceX。当处理文本渲染一个字形后，笔位置必须增加（从左向右）或减少（从右向左）的水平距离。对水平布局总是正值，垂直布局为null。&nbsp;<br><br>* 步进高度或advanceY。当每个字形渲染后，笔位置必须减少的垂直距离。对水平布局为null，对垂直布局总是正值。&nbsp;<br><br>* 字形宽度。字形的水平长度。对未缩放的字体坐标，它是bbox.xMax-bbox.xMin，对已缩放字形，它的计算要看特定情况，视乎不同的网格对齐而定。&nbsp;<br><br>* 字形高度。字形的垂直长度。对未缩放的字体坐标，它是bbox.yMax-bbox.yMin，对已缩放字形，它的计算要看特定情况，视乎不同的网格对齐而定。&nbsp;<br><br>* 右跨距。只用于水平布局，描述从bbox右边到步进宽度的距离，通常是一个非负值。&nbsp;<br><br>advance_width – left_side_bearing – (xMax-xMin)&nbsp;<br><br>下图是水平布局所有的度量&nbsp;<br><br><br>下图是垂直布局的度量&nbsp;<br><br><br>4、网格对齐的效果&nbsp;<br>因为hinting将字形的控制点对齐到象素网格，这个过程将稍稍修改字符映象的尺寸，和简单的缩放有所区别。例如，小写字母m的映象在主网格中 有时是一个正方形，但是为了使它在小象素大小情况下可以辨别，hinting试图扩大它已缩放轮廓，以让它三条腿区分开来，这将导致一个更大的字符位图。&nbsp;<br><br>字形度量也会受网格对齐过程的影响：&nbsp;<br><br>* 映象的宽度和高度改变了，即使只是一个象素，对于小象素大小字形区别都很大；&nbsp;<br><br>* 映象的边界框改变了，也改变了跨距；&nbsp;<br><br>* 步进必须更改，例如如果被hint的位图比缩放的位图大时，必须增加步进宽度，来反映扩大的字形宽度。&nbsp;<br><br>这有一些含义如下，&nbsp;<br><br>* 因为hinting，简单缩放字体上行或下行高度可能不会有正确的结果，一个可能的方法时保持被缩放上行高度的顶和被缩放下行高度的底。&nbsp;<br><br>* 没有容易的方法去hint一个范围内字形并步进它们宽度，因为hinting对每个轮廓工作都不一样。唯一的方法时单独hint每个字形，并记录返回值。有些格式，如TrueType，包含一些表对一些通用字符预先计算出它们的象素大小。&nbsp;<br><br>* hinting依赖最终字符宽度和高度的象素值，意味着它非常依赖分辨率，这个特性使得正确的所见即所得布局非常难以实现。&nbsp;<br><br>在FT 中，对字形轮廓处理2D变换很简单，但是对一个已hint的轮廓，需要注意专有地使用整型象素距离（意味着FT_Outline_Translate() 函数的参数应该都乘以64，因为点坐标都是26.6固定浮点格式），否则，变换将破坏hinter的工作，导致非常难看的位图。&nbsp;<br><br>5、文本宽度和边界框&nbsp;<br>如上所示，指定字形的原点对应基线上笔的位置，没有必要定位字形边界框的某个角，这不像多数典型的位图字体格式。有些情况，原点可以在边界框的外边，有时，也可以在里边，这要看给定的字形外形了。&nbsp;<br><br>同样，字形的步进宽度是在布局时应用于笔位置的增量，而不是字形的宽度，那是字形边界的宽度。对文本串，具有相同的规约，这意味着：&nbsp;<br><br>* 指定文本串的边界框没有必要包含文本光标，也不需要后边的字形放置在它的角上。&nbsp;<br><br>* 字符串的步进宽度和它的边界框大小无关，特别时它在开始和最后包含空格或tab。&nbsp;<br><br>* 最后，附加的处理如间距调整能够创建文本串，它的大小不直接依赖单独字形度量并列排列。例如，VA的步进宽度不是V和A各自的步进之和。&nbsp;<br><br><br>四、字距调整&nbsp;<br>字距调整这个术语指用来在一个文本串中调整重合字形的相对位置的特定信息。&nbsp;<br><br>1、字距调整对&nbsp;<br>字距调整包括根据相邻字形的轮廓修改它们之间的距离。例如T和y可以贴得更近一点，因为y的上缘正好在T的右上角一横的下边。&nbsp;<br><br>当仅仅根据字形的标准宽度来布局文本，一些连续的字符看上去有点太挤和太松，例如下图中A和V的就显得距离太远。&nbsp;<br><br><br>比较一下下图，同样的单词，A和V的距离拉近些&nbsp;<br><br><br>可以看到，这个调整可以导致很大的区别。有的字体外观包含一个表，它包含文本布局所需的指定字形对的字距距离。&nbsp;<br><br>* 这个对是顺序的，AV对的距离和VA对不一定一致；&nbsp;<br><br>* 依据布局或书写，字距可以表示水平或垂直方向。&nbsp;<br><br>* 字距表示成网格单元，它们通常是X轴方向的，意味着负值表示两个字形需要在水平方向放的更近一点。&nbsp;<br><br>2、应用字距调整&nbsp;<br>在渲染文本时应用字据调整是一个比较简单的过程，只需要在写下一个字形时，将缩放的字距加到笔位置即可。然而，正确的渲染器要考虑的更细一点。&nbsp;<br><br>“滑动点”问题是一个很好的例子：很多字体外观包括一个大写字符（如T、F）和一个点.之间的字距调整，以将点正好放置在前者的主腿的右侧。&nbsp;<br><br><br>根据字符的外形，有时候需要在点和随后的字符间作附加的调整，当应用“标准”的字距调整，上面的句子如下&nbsp;<br><br><br>这显然太紧凑了。一个方案是，只在需要时滑动点，当然这需要对文本的意思有了解。如果当我们在渲染特定段落的最后一个点时，上面的调整就不适合了。这只是一个例子，还有很多其他例子显示一个真正的印刷工人需要恰当地布局文本。&nbsp;<br><br>有一个很简单地算法，可以避免滑动点问题。&nbsp;<br><br>1. 在基线上放置第一个字形；&nbsp;<br>2. 将笔位置保存到pen1；&nbsp;<br>3. 根据第一个和第二个字形的字距距离调整笔位置；&nbsp;<br>4. 放置第二个字形，并计算下个笔位置，放到pen2；&nbsp;<br>5. 如果pen1大于pen2，使用pen1作为下个笔位置，否则使用pen2。&nbsp;<br><br><br>五、文本处理&nbsp;<br>1、书写简单文本串&nbsp;<br>在第一个例子中，我们将生成一个简单的Roman文字串，即采用水平的自左向右布局，使用专有的象素度量，这个过程如下：&nbsp;<br><br>1. 将字符串转换成一系列字形索引；&nbsp;<br>2. 将笔放置在光标位置；&nbsp;<br>3. 获得或装入字形映象；&nbsp;<br>4. 平移字形以使它的原点匹配笔位置；&nbsp;<br>5. 将字形渲染到目标设备；&nbsp;<br>6. 根据字形的步进象素增加笔位置；&nbsp;<br>7. 对剩余的字形进行第三步；&nbsp;<br>8. 当所有字形都处理了，在新的笔位置设置文本光标。&nbsp;<br><br>注意字距调整不在这个算法中。&nbsp;<br><br>2、子象素定位&nbsp;<br>在渲染文本时使用子象素定位有时很有用。这非常重要，例如为了提供半所见即所得的文本布局，文本渲染的算法和上一节很相似，但是有些区别：&nbsp;<br><br>* 笔位置表示成小数形式的象素；&nbsp;<br>* 因为将一个已经hint过的轮廓平移一个非整型距离将破坏网格对齐，字形原点的位置在渲染字符映象前必须取整；&nbsp;<br>* 步进宽度表示成小数形式的象素，没有必要是整型。&nbsp;<br><br>这里是算法的改进版本：&nbsp;<br><br>1. 将字符串转换成一系列字形索引；&nbsp;<br>2. 将笔放置在光标位置，这可以是一个非整型点；&nbsp;<br>3. 获得或装入字形映象；&nbsp;<br>4. 平移字形以使它的原点匹配取整后的笔位置；&nbsp;<br>5. 将字形渲染到目标设备；&nbsp;<br>6. 根据字形的步进象素宽度增加笔位置，这个宽度可以是小数形式；&nbsp;<br>7. 对剩余的字形进行第三步；&nbsp;<br>8. 当所有字形都处理了，在新的笔位置设置文本光标。&nbsp;<br><br>注意使用小数象素定位后，两个指定字符间的空间将不是固定的，它右先前的取整操作堆积的数决定。&nbsp;<br><br>3、简单字距调整&nbsp;<br>在基本文本渲染算法上增加字距调整非常简单，当一个字距调整对发现了，简单地在第4步前，将缩放后的调整距离增加到笔位置即可。淡然，这个距离在算法1需要被取整，算法2不必要。&nbsp;<br><br>4、自右向左布局&nbsp;<br>布局Arabic或Heberw文字的过程非常相似，区别只是在字形渲染前，笔位置需要减少（记住步进宽度总是正值）&nbsp;<br><br>5、垂直布局&nbsp;<br>布局垂直文字也是同样的过程，重要的区别如下：&nbsp;<br><br>* 基线是垂直的，使用垂直的度量而不是水平度量；&nbsp;<br>* 左跨距通常是负的，但字形原点必须在基线上；&nbsp;<br>* 步进高度总是正值，所以笔位置必须减少以从上至下书写；&nbsp;<br><br>6、所见即所得布局&nbsp;<br><br><br>六、FT轮廓&nbsp;<br>1、FT轮廓描述和结构&nbsp;<br>a. 轮廓曲线分解&nbsp;<br>一个轮廓是2D平面上一系列封闭的轮廓线。每个轮廓线由一系列线段和Bezier弧组成，根据文件格式不同，曲线可以是二次和三次多项式，前者叫quadratic或conic弧，它们在TrueType格式中用到，后者叫cubic弧，多数用于Type1格式。&nbsp;<br><br>每条弧由一系列起点、终点和控制点描述，轮廓的每个点有一个特定的标记，表示它用来描述一个线段还是一条弧。这个标记可以有以下值：&nbsp;<br><br>FT_Curve_Tag_On	 当点在曲线上，这对应线段和弧的起点和终点。其他标记叫做“Off”点，即它不在轮廓线上，但是作为Bezier弧的控制点。&nbsp;<br>FT_Curve_Tag_Conic	一个Off点，控制一个conic Bezier弧&nbsp;<br>FT_Curve_Tag_Cubic	一个Off点，控制一个cubic Bezier弧&nbsp;<br><br>下面的规则应用于将轮廓点分解成线段和弧&nbsp;<br><br>* 两个相邻的“on”点表示一条线段；&nbsp;<br>* 一个conic Off点在两个on点之间表示一个conic Bezier弧，off点是控制点，on点是起点和终点；&nbsp;<br>* 两个相邻的cubic off点在两个on点之间表示一个cubic Bezier弧，它必须有两个cubic控制点和两个on点。&nbsp;<br>* 最后，两个相邻的conic off点强制？？在它们正中间创建一个虚拟的on点。这大大方便定义连续的conic弧。TrueType规范就是这么定义的。&nbsp;<br><br>注意，在单个轮廓线中可以混合使用conic和cubic弧，不过现在没有那种字体驱动产生这样的轮廓。&nbsp;<br><br><br><br>b. 轮廓描述符&nbsp;<br>FT轮廓通过一个简单的结构描述&nbsp;<br><br>FT_Outline&nbsp;<br>n_points	轮廓中的点数&nbsp;<br>n_contours	轮廓中轮廓线数&nbsp;<br>points	 点坐标数组&nbsp;<br>contours	轮廓线端点索引数组&nbsp;<br>tags	 点标记数组&nbsp;<br><br>这里，points是一个FT_Vector记录数组的指针，用来存储每个轮廓点的向量坐标。它表示为一个象素1/64，也叫做26.6固定浮点格式。&nbsp;<br><br>contours是一组点索引，用来划定轮廓的轮廓线。例如，第一个轮廓线总是从0点开始，以contours[0]点结束。第二个轮廓线从contours[0]+1点开始，以contours[1]结束，等等。&nbsp;<br><br>注意，每条轮廓线都是封闭的，n_points应该和contours[n_controus-1]+1相同。最后，tags是一组字节，用来存放每个轮廓的点标记。&nbsp;<br><br>2、边界和控制框计算&nbsp;<br>边界框（bbox）是一个完全包含指定轮廓的矩形，所要的是最小的边界框。因为弧的定义，bezier的控制点无需包含在轮廓的边界框中。例如轮 廓的上缘是一个Bezier弧，一个off点就位于bbox的上面。不过这在字符轮廓中很少出现，因为大多字体设计者和创建工具都会在每个曲线拐点处放一 个on点，这会使hinting更加容易。于是我们定义了控制框（cbox），它是一个包含轮廓所有点的最小矩形，很明显，它包含bbox，通常它们是一 样的。不想 bbox，cbox计算起来非常快。&nbsp;<br><br><br>控制框和边界框可以通过函数FT_Outline_Get_CBox()和 FT_Outline_Get_BBox()自动计算，前者总是非常快，后者在有外界控制点的情况下会慢一点，因为需要找到conic和cubic弧的末 端，如果不是这种情况，它和计算控制框一样快。&nbsp;<br><br>注意，虽然大多字形轮廓为易于hint具有相同的cbox和bbox，这在它们进行变换以后，如旋转，就不再是这种情况了。&nbsp;<br><br>3、坐标、缩放和网格对齐&nbsp;<br>轮廓点的向量坐标表示为26.6格式，即一个象素的1/64。因此，坐标（1.0,-2.5）存放整型对（x:64,y:-192）。&nbsp;<br><br>在主字形轮廓从EM网格缩放到当前字符大小后，hinter负责对齐重要的轮廓点到象素网格。虽然这个过程很难几句话说清楚，但是它的目的也就是取整点的位置，以保持字形重要的特性，如宽度、主干等。下面的操作可以用来将26.6格式的向量距离取整到网格：&nbsp;<br><br>round(x) == (x + 32) &amp; -64&nbsp;<br>floor(x) == x &amp; -64&nbsp;<br>ceiling(x) == (x + 63) &amp; -64&nbsp;<br><br>一旦一个字形轮廓经过对齐或变换，在渲染之前通常要计算字形的映象象素大小。做到这一点，必须考虑如下：&nbsp;<br><br>扫描线转换器画出所有中心在字形形状中的象素，他也可以检测drop-outs？？？&nbsp;<br><br>这导致如下的计算：&nbsp;<br><br>* 计算bbox；&nbsp;<br>* 对齐bbox如下：&nbsp;<br>xmin = floor(bbox.xMin)&nbsp;<br>xmax = ceiling(bbox.xMax)&nbsp;<br>ymin = floor(bbox.yMin)&nbsp;<br>ymax = ceiling(bbox.yMax)&nbsp;<br>* 返回象素尺寸，即&nbsp;<br>width = (xmax-xmin) / 64&nbsp;<br>和&nbsp;<br>height = (ymax-ymin) / 64&nbsp;<br><br>通过对齐bbox，可以保证所有的象素中心将画到，包括那些从drop-out控制来的，将在调整后的框子之中。接着，框子的象素尺寸可以计算出来。&nbsp;<br><br>同时注意，当平移一个对齐的轮廓，应该总是使用整型距离来移动。否则，字形的边缘将不再对齐象素网格，hinter的工作将无效，产生非常难看的位图。&nbsp;<br><br><br>七、FT位图&nbsp;<br>1、向量坐标和象素坐标对比&nbsp;<br>这里阐述了向量坐标的象素坐标的区别，为了更清楚的说明，使用方括号来表示象素坐标，使用圆括号表示向量坐标。&nbsp;<br><br>在象素坐标中，我们使用Y轴向上的规约，坐标[0,0]总是指位图左下角象素，坐标[width-1, rows-1]是右上角象素。在向量坐标中，点坐标用浮点单位表示，如(1.25, -2.3)，这个位置并不是指一个特定象素，而是在2D平面上一个非实质性的点。&nbsp;<br><br>象素其实在2D平面上是一个方块，它的中心是象素坐标值的一半，例如位图的左下角象素通过方块(0,0)-(1,1)界定，它的中心位于 (0.5,0.5)。注意这儿用的是向量坐标表示。这对计算距离就会发生一些区别。例如，[0,0]-[10.0]一条线的象素长度是11，然而， (0,0)-(10,0)的向量程度覆盖了10个象素，因此它的长度是10。&nbsp;<br><br><br>2、FT位图和象素图描述符&nbsp;<br>一个位图和象素图通过一个叫FT_Bitmap的单一结构描述，他定义在&lt;freetype/ftimage.h&gt;中，属性如下&nbsp;<br><br>FT_Bitmap&nbsp;<br>rows	 行数，即位图中的水平线数&nbsp;<br>width	 位图的水平象素数&nbsp;<br>pitch	 它的绝对值是位图每行占的字节数，根据位图向量方向，可以是正值或是负值&nbsp;<br>buffer	 一个指向位图象素缓冲的无类型指针&nbsp;<br>pixel_mode	一个枚举值，用来表示位图的象素格式；例如ft_pixel_mode_mono表示1位单色位图，ft_pixel_mode_grays表示8位反走样灰度值&nbsp;<br>num_grays	这只用于灰度象素模式，它给出描述反走样灰度级别的级数，FT缺省值为255。&nbsp;<br><br>pitch 属性值的正负符号确定象素缓冲中的行是升序还是降序存放。上面说道FT在2D平面上使用Y轴向上的规约，这意味着(0,0)总是指向位图的左下角。如果 picth是正值，按照向量减少的方向存储行，即象素缓冲的第一个字节表示位图最上一行的部分。如果是负值，第一个字节将表示位图最下一行的部分。对所有 的情况，pitch可以看作是在指定位图缓冲中，跳到下一个扫描行的字节增量。&nbsp;<br><br><br>通常都使用正pitch，当然有的系统会使用负值。&nbsp;<br><br>3、轮廓转换到位图和象素图&nbsp;<br>使用FT从一个向量映象转换到位图和象素图非常简单，但是，在转换前，必须理解有关在2D平面上放置轮廓的一些问题：&nbsp;<br><br>* 字形转载器和hinter在2D平面上放置轮廓时，总将(0,0)匹配到字符原点，这意味着字形轮廓，及对应的边界框，可以在平面中放置于任何地方。&nbsp;<br><br>* 目标位图映射到2D平面上，左下角在(0,0)上，这就是说一个[w,h]大小的位图和象素图将被映射到(0,0)-(w,h)界定的2D矩形窗口。&nbsp;<br><br>* 当扫描转换轮廓，所有在这个位图窗口的部分将被渲染，其他的被忽略。&nbsp;<br><br>很多使用FT的开发者都会有个误解，认为一个装入的轮廓可以直接渲染成一个适当大小的位图，下面的图像表明这个问题。&nbsp;<br><br>* 第一个图表明一个2D平面上一个装入的轮廓；&nbsp;<br><br>* 第二个表示一个任意大小[w,h]维护的目标窗口；&nbsp;<br><br>* 第三个表示在2D平面上轮廓和窗口的合并；&nbsp;<br><br>* 最后一个表示位图实际被渲染的部分。&nbsp;<br><br><br>实际上，几乎所有的情况，装入或变换过的轮廓必须在渲染成目标位图之前作平移操作，以调整到相对目标窗口的位置。&nbsp;<br><br>例如，创建一个单独的字形位图正确的方法如下：&nbsp;<br><br>* 计算字形位图的大小，可以直接从字形度量计算出来，或者计算它的边界框（这在经过变换后非常有用，此时字形度量不再有效）。&nbsp;<br><br>* 根据计算的大小创建位图，别忘了用背景色填充象素缓冲；&nbsp;<br><br>* 平移轮廓，使左下角匹配到(0,0)。别忘了为了hinting，应该使用整型。通常，这就是说平移一个向量（-ROUND(xMin), -ROUND(yMin)）。&nbsp;<br><br>* 调用渲染功能，例如FT_Outline_Render()函数。&nbsp;<br><br>在将字形映象直接写入一个大位图的情况，轮廓必须经过平移，以将它们的向量位置对应到当前文本光标/字符原点上。&nbsp;<br></span></td>
<td><ins><ins id="google_ads_frame3_anchor"></ins></ins></td>
</tr>
<tr>
<td colspan="2">
<div>----</div>
<div>良好的沟通能力 和 积极的行动 是成功的钥匙。</div>
</td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592189&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
</tbody>
</table>
<a name="article592190"></a>
<table border="0">
<tbody>
<tr>
<td colspan="2"><span><span>Subject</span>:&nbsp;<span>[精华] Re: FreeType 2开发文档 [中译版]</span></span>&nbsp;<br><span><span>Author</span>:&nbsp;<span><a href="http://www.linuxforum.net/forum/showprofile.php?User=gogoliu&amp;What=kylix" target="_blank">gogoliu</a></span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Posted</span>:&nbsp;<span>2006-01-23 19:14</span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Length</span>:&nbsp;<span>15,143</span>&nbsp;byte(s)</span></td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592190&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
<tr>
<td><span>《The design of FreeType 2》中译版&nbsp;<br><br>FreeType 2的设计&nbsp;<br><br>介绍&nbsp;<br>这份文档提供了FreeType 2函数库设计与实现的细节。本文档的目标是让开发人员更好的理解FreeType 2是如何组织的，并让他们扩充、定制和调试它。&nbsp;<br>首先，我们先了解这个库的目的，也就是说，为什么会写这个库：&nbsp;<br>* 它让客户应用程序方便的访问字体文件，无论字体文件存储在哪里，并且与字体格式无关。<br>* 方便的提取全局字体数据，这些数据在平常的字体格式中普遍存在。（例如：全局度量标准，字符编码/字符映射表，等等）&nbsp;<br>* 方便的提取某个字符的字形数据（度量标准，图像，名字，其他任何东西）&nbsp;<br>* 访问字体格式特定的功能（例如，SFNT表，多重控制，OpenType轮廓表）&nbsp;<br>Freetype 2的设计也受如下要求很大的影响：&nbsp;<br>* 高可移植性。这个库必须可以运行在任何环境中。这个要求引入了一些非常激烈的选择，这些是FreeType2的低级系统界面的一部分。&nbsp;<br>* 可扩展性。新特性应该可以在极少改动库基础代码的前提下添加。这个要求引入了非常简单的设计：几乎所有操作都是以模块的形式提供的。&nbsp;<br>* 可定制。它应该能够很容易建立一个只包含某个特定项目所需的特性的版本。当你需要集成它到一个嵌入式图形库的字体服务器中时，这是非常重要的。&nbsp;<br>* 简洁高效。这个库的主要目标是只有很少cpu和内存资源的嵌入式系统。&nbsp;<br>这份文档的其他部分分为几个部分。首先，一些章节介绍了库的基本设计以及Freetype 2内部对象/数据的管理。&nbsp;<br>接下来的章节专注于库的定制和与这个话题相关的系统特定的界面，如何写你自己的模块和如何按需裁减库初始化和编译。&nbsp;<br><br><br>一、组件和API&nbsp;<br>FT可以看作是一组组件，每个组件负责一部分任务，它们包括&nbsp;<br><br>* 客户应用程序一般会调用FT高层API，它的功能都在一个组件中，叫做基础层。&nbsp;<br>* 根据上下文和环境，基础层会调用一个或多个模块进行工作，大多数情况下，客户应用程序不知道使用那个模块。&nbsp;<br>* 基础层还包含一组例程来进行一些共通处理，例如内存分配，列表处理、io流解析、固定点计算等等，这些函数可以被模块随意调用，它们形成了一个底层基础API。&nbsp;<br><br>如下图，表明它们的关系&nbsp;<br><br><br>另外，&nbsp;<br><br>* 为了一些特殊的构建，基础层的有些部分可以替换掉，也可以看作组件。例如ftsystem组件，负责实现内存管理和输入流访问，还有ftinit，负责库初始化。&nbsp;<br>* FT还有一些可选的组件，可以根据客户端应用灵活使用，例如ftglyph组件提供一个简单的API来管理字形映象，而不依赖它们内部表示法。或者是访问特定格式的特性，例如ftmm组件用来访问和管理Type1字体中Multiple Masters数据。&nbsp;<br>* 最后，一个模块可以调用其他模块提供的函数，这对在多个字体驱动模块中共享代码和表非常有用，例如truetype和cff模块都使用sfnt模块提供的函数。&nbsp;<br><br>见下图，是对上图的一个细化。&nbsp;<br><br><br>请注意一些要点：&nbsp;<br><br>* 一个可选的组件可以用在高层API，也可以用在底层API，例如上面的ftglyph；&nbsp;<br>* 有些可选组件使用模块特定的接口，而不是基础层的接口，上例中，ftmm直接访问Type1模块来访问数据；&nbsp;<br>* 一个可替代的组件能够提供一个高层API的函数，例如，ftinit提供FT_Init_FreeType()&nbsp;<br><br><br>二、公共对象和类&nbsp;<br><br><br>1、FT中的面向对象&nbsp;<br>虽然FT是使用ANSI C编写，但是采用面向对象的思想，是这个库非常容易扩展，因此，下面有一些代码规约。&nbsp;<br><br>1. 每个对象类型/类都有一个对应的结构类型和一个对应的结构指针类型，后者称为类型/类的句柄类型&nbsp;<br><br>设想我们需要管理FT中一个foo类的对象，可以定义如下&nbsp;<br><br>typedef struct FT_FooRec_* FT_Foo;&nbsp;<br><br>typedef struct FT_FooRec_&nbsp;<br><br>{&nbsp;<br><br>// fields for the foo class&nbsp;<br><br>…&nbsp;<br><br>}FT_FooRec;&nbsp;<br><br>依照规约，句柄类型使用简单而有含义的标识符，并以FT_开始，如FT_Foo，而结构体使用相同的名称但是加上Rec后缀。Rec是记录的缩写。每个类类型都有对应的句柄类型；&nbsp;<br><br>2. 类继承通过将基类包装到一个新类中实现，例如，我们定义一个foobar类，从foo类继承，可以实现为&nbsp;<br><br>typedef struct FT_FooBarRec_ * FT_FooBar;&nbsp;<br><br>typedef struct FT_FooBarRec_&nbsp;<br>{&nbsp;<br>FT_FooRec root; //基类&nbsp;<br><br>}FT_FooBarRec;&nbsp;<br><br>可以看到，将一个FT_FooRec放在FT_FooBarRec定义的开始，并约定名为root，可以确保一个foobar对象也是一个foo对象。&nbsp;<br><br>在实际使用中，可以进行类型转换。&nbsp;<br><br>后面&nbsp;<br><br>2、FT_Library类&nbsp;<br>这个类型对应一个库的单一实例句柄，没有定义相应的FT_LibraryRec，使客户应用无法访问它的内部属性。&nbsp;<br><br>库对象是所有FT其他对象的父亲，你需要在做任何事情前创建一个新的库实例，销毁它时会自动销毁他所有的孩子，如face和module等。&nbsp;<br><br>通常客户程序应该调用FT_Init_FreeType()来创建新的库对象，准备作其他操作时使用。&nbsp;<br><br>另一个方式是通过调用函数FT_New_Library()来创建一个新的库对象，它在&lt;freetype/ftmodule.h&gt;中定义，这个函数返回一个空的库，没有任何模块注册，你可以通过调用FT_Add_Module()来安装模块。&nbsp;<br><br>调用FT_Init_FreeType()更方便一些，因为他会缺省地注册一些模块。这个方式中，模块列表在构建时动态计算，并依赖ftinit部件的内 容。（见ftinit.c[l73]行，include FT_CONFIG_MODULES_H，其实就是包含ftmodule.h，在ftmodule.h中定义缺省的模块，所以模块数组 ft_default_modules的大小是在编译时动态确定的。）&nbsp;<br><br>3、FT_Face类&nbsp;<br>一个外观对象对应单个字体外观，即一个特定风格的特定外观类型，例如Arial和Arial Italic是两个不同的外观。&nbsp;<br><br>一个外观对象通常使用FT_New_Face()来创建，这个函数接受如下参数：一个FT_Library句柄，一个表示字体文件的C文件路径名，一个决定从文件中装载外观的索引（一个文件中可能有不同的外观），和FT_Face句柄的地址，它返回一个错误码。&nbsp;<br><br>FT_Error FT_New_Face( FT_Library library,&nbsp;<br>const char* filepathname,&nbsp;<br>FT_Long face_index,&nbsp;<br>FT_Face* face);&nbsp;<br><br>函数调用成功，返回0，face参数将被设置成一个非NULL值。&nbsp;<br><br>外观对象包含一些用来描述全局字体数据的属性，可以被客户程序直接访问。例如外观中字形的数量、外观家族的名称、风格名称、EM大小等，详见FT_FaceRec定义。&nbsp;<br><br>4、FT_Size类&nbsp;<br>每个FT_Face对象都有一个或多个FT_Size对象，一个尺寸对象用来存放指定字符宽度和高度的特定数据，每个新创建的外观对象有一个尺寸，可以通过face-&gt;size直接访问。&nbsp;<br><br>尺寸对象的内容可以通过调用FT_Set_Pixel_Sizes()或FT_Set_Char_Size()来改变。&nbsp;<br><br>一个新的尺寸对象可以通过FT_New_Size()创建，通过FT_Done_Size()销毁，一般客户程序无需做这一步，它们通常可以使用每个FT_Face缺省提供的尺寸对象。&nbsp;<br><br>FT_Size 公共属性定义在FT_SizeRec中，但是需要注意的是有些字体驱动定义它们自己的FT_Size的子类，以存储重要的内部数据，在每次字符大小改变时 计算。大多数情况下，它们是尺寸特定的字体hint。例如，TrueType驱动存储CVT表，通过cvt程序执行将结果放入TT_Size结构体中，而 Type1驱动将scaled global metrics放在T1_Size对象中。&nbsp;<br><br>5、FT_GlyphSlot类&nbsp;<br>字形槽的目的是提供一个地方，可以很容易地一个个地装入字形映象，而不管它的格式（位图、向量轮廓或其他）。理想的，一旦一个字形槽创建了，任何字形映象 可以装入，无需其他的内存分配。在实际中，只对于特定格式才如此，像TrueType，它显式地提供数据来计算一个槽地最大尺寸。&nbsp;<br><br>另一个字形槽地原因是他用来为指定字形保存格式特定的hint，以及其他为正确装入字形的必要数据。&nbsp;<br><br>基本的FT_GlyphSlotRec结构体只向客户程序展现了字形metics和映象，而真正的实现回包含更多的数据。&nbsp;<br><br>例如，TrueType特定的TT_GlyphSlotRec结构包含附加的属性，存放字形特定的字节码、在hint过程中暂时的轮廓和其他一些东西。&nbsp;<br><br>最后，每个外观对象有一个单一字形槽，可以用face-&gt;glyph直接访问。&nbsp;<br><br>6、FT_CharMap类&nbsp;<br>FT_CharMap类型用来作为一个字符地图对象的句柄，一个字符图是一种表或字典，用来将字符码从某种编码转换成字体的字形索引。&nbsp;<br><br>单个外观可能包含若干字符图，每个对应一个指定的字符指令系统，例如Unicode、Apple Roman、Windows codepages等等。&nbsp;<br><br>每个FT_CharMap对象包含一个platform和encoding属性，用来标识它对应的字符指令系统。每个字体格式都提供它们自己的FT_CharMapRec的继承类型并实现它们。&nbsp;<br><br>7、对象关系&nbsp;<br><br><br>三、内部对象和类&nbsp;<br>1、内存管理&nbsp;<br>所有内存管理操作通过基础层中3个特定例程完成，叫做FT_Alloc、FT_Realloc、 FT_Free，每个函数需要一个 FT_Memory句柄作为它的第一个参数。它是一个用来描述当前内存池/管理器对象的指针。在库初始化时，在FT_Init_FreeType中调用函 数FT_New_Memory创建一个内存管理器，这个函数位于ftsystem部件当中。&nbsp;<br><br>缺省情况下，这个管理器使用ANSI malloc、realloc和free函数，不过ftsystem是基础层中一个可替换的部分，库的特定构建可以提供不同的内存管理器。即使使用缺省的 版本，客户程序仍然可以提供自己的内存管理器，通过如下的步骤，调用FT_Init_FreeType实现：&nbsp;<br><br>1. 手工创建一个FT_Memory对象，FT_MemoryRec位于公共文件&lt;freetype/ftsystem.h&gt;中。<br><br>2. 使用你自己的内存管理器，调用FT_New_Library()创建一个新的库实例。新的库没有包含任何已注册的模块。&nbsp;<br><br>3. 通过调用函数FT_Add_Default_Modules()（在ftinit部件中）注册缺省的模块，或者通过反复调用FT_Add_Module手工注册你的驱动。&nbsp;<br><br>2、输入流&nbsp;<br>字体文件总是通过FT_Stream对象读取，FT_StreamRec的定义位于公共文 件&lt;freetype/ftsystem.h&gt;中，可以允许客户开发者提供自己的流实现。FT_New_Face()函数会自动根据他第二个 参数，一个C路径名创建一个新的流对象。它通过调用由 ftsystem部件提供的FT_New_Stream()完成，后者时可替换的，在不同平台上，流的实现可能大不一样。&nbsp;<br><br>举例来说，流的缺省实现位于文件src/base/ftsystem.c并使用ANSI fopen/fseek和fread函数。不过在FT2的Unix版本中，提供了另一个使用内存映射文件的实现，对于主机系统来说，可以大大提高速度。&nbsp;<br><br>FT区分基于内存和基于磁盘的流，对于前者，所有数据在内存直接访问（例如ROM、只写静态数据和内存映射文件），而后者，使用帧（frame）的概念从字体文件中读出一部分，使用典型的seek/read操作并暂时缓冲。&nbsp;<br><br>FT_New_Memory_Face 函数可以用来直接从内存中可读取的数据创建/打开一个FT_Face对象。最后，如果需要客户输入流，客户程序能够使用FT_Open_Face()函数 接受客户输入流。这在压缩或远程字体文件的情况下，以及从特定文档抽取嵌入式字体文件非常有用。&nbsp;<br><br>注意每个外观拥有一个流，并且通过FT_Done_Face被销毁。总的来说，保持多个FT_Face在打开状态不是一个很好的主意。&nbsp;<br><br>3、模块&nbsp;<br>FT2 模块本身是一段代码，库调用FT_Add_Moudle（）函数注册模块，并为每个模块创建了一个FT_Module对象。FT_ModuleRec的定 义对客户程序不是公开的，但是每个模块类型通过一个简单的公共结构FT_Module_Class描述，它定义在&lt; freetype/ftmodule.h&gt;中，后面将详述。&nbsp;<br><br>当调用FT_Add_Module是，需要指定一个FT_Module_Class结构的指针，它的声明如下：&nbsp;<br><br>FT_Error FT_Add_Module( FT_Library library,&nbsp;<br><br>const FT_Module_Class* clazz);&nbsp;<br><br>调用这个函数将作如下操作：&nbsp;<br><br>* 检查库中是否已经有对应FT_Module_Class指名的模块对象；&nbsp;<br><br>* 如果是，比较模块的版本号看是否可以升级，如果模块类的版本号小于已装入的模块，函数立即返回。当然，还要检查正在运行的FT版本是否满足待装模块所需FT的版本。&nbsp;<br><br>* 创建一个新的FT_Module对象，使用模块类的数据的标志决定它的大小和如何初始化；&nbsp;<br><br>* 如果在模块类中有一个模块初始器，它将被调用完成模块对象的初始化；&nbsp;<br><br>* 新的模块加入到库的“已注册”模块列表中，对升级的情况，先前的模块对象只要简单的销毁。&nbsp;<br><br>注意这个函数并不返回FT_Module句柄，它完全是库内部的事情，客户程序不应该摆弄他。最后，要知道FT2识别和管理若干种模块，这在后面将有详述，这里列举如下：&nbsp;<br><br>* 渲染器模块用来将原始字形映象转换成位图或象素图。FT2自带两个渲染器，一个是生成单色位图，另一个生成高质量反走样的象素图。&nbsp;<br><br>* 字体驱动模块用来支持多种字体格式，典型的字体驱动需要提供特定的FT_Face、FT_Size、FT_GlyphSlot和FT_CharMap的实现；&nbsp;<br><br>* 助手模块被多个字体驱动共享，例如sfnt模块分析和管理基于SFNT字体格式的表，用于TrueType和OpenType字体驱动；&nbsp;<br><br>* 最后，auto-hinter模块在库设计中有特殊位置，它不管原始字体格式，处理向量字形轮廓，使之产生优质效果。&nbsp;<br><br>注意每个FT_Face对象依据原始字体文件格式，都属于相应的字体驱动。这就是说，当一个模块从一个库实例移除/取消注册后，所有的外观对象都被销毁（通常是调用FT_Remove_Module()函数）。&nbsp;<br><br>因此，你要注意当你升级或移除一个模块时，没有打开FT_Face对象，因为这会导致不预期的对象删除。&nbsp;<br><br>4、库&nbsp;<br>现在来说说FT_Library对象，如上所述，一个库实例至少包含如下：&nbsp;<br><br>* 一个内存管理对象（FT_Memory），用来在实例中分配、释放内存；&nbsp;<br><br>* 一个FT_Module对象列表，对应“已安装”或“已注册”的模块，它可以随时通过FT_Add_Module()和FT_Remove_Module()管理；&nbsp;<br><br>* 记住外观对象属于字体驱动，字体驱动模块属于库。&nbsp;<br><br>还有一个对象属于库实例，但仍未提到：raster pool&nbsp;<br><br>光栅池是一个固定大小的一块内存，为一些内存需要大的操作作为内部的“草稿区域”，避免内存分配。例如，它用在每个渲染器转换一个向量字形轮廓到一个位图时（这其实就是它为何叫光栅池的原因）。&nbsp;<br><br>光栅池的大小在初始化的时候定下来的（缺省为16k字节），运行期不能修改。当一个瞬时操作需要的内存超出这个池的大小，可以另外分配一块作为例外条件，或者是递归细分任务，以确保不会超出池的极限。&nbsp;<br><br>这种极度的内存保守行为是为了FT的性能考虑，特别在某些地方，如字形渲染、扫描线转换等。&nbsp;<br><br>5、总结&nbsp;<br>最后，下图展示的上面所述内容，他表示FT基本设计的对象图&nbsp;<br><br><br>四、模块类&nbsp;<br><br>在FT中有若干种模块&nbsp;<br><br>* 渲染模块，用来管理可缩放的字形映象。这意味这转换它们、计算边框、并将它们转换成单色和反走样位图。FT可以处理任何类型的字形映像，只要为它提供了一个渲染模块，FT缺省带了两个渲染器&nbsp;<br><br>raster 支持从向量轮廓（由FT_Outline对象描述）到单色位图的转换&nbsp;<br><br>smooth 支持同样的轮廓转换到高质量反走样的象素图，使用256级灰度。这个渲染器也支持直接生成span。&nbsp;<br><br>* 字体驱动模块，用来支持一种或多种特定字体格式，缺省情况下，FT由下列字体驱动&nbsp;<br><br>truetype 支持TrueType字体文件&nbsp;<br><br>type1 支持PostScript Type1字体，可以是二进制（.pfb）和ASCII(.pfa)格式，包括Multiple Master字体&nbsp;<br><br>cid 支持Postscript CID-keyed字体&nbsp;<br><br>cff 支持OpenType、CFF和CEF字体（CEF是CFF的一个变种，在Adobe的SVG Viewer中使用&nbsp;<br><br>winfonts 支持Windows位图字体，.fon和.fnt&nbsp;<br><br><br>字体驱动可以支持位图和可缩放的字形映象，一个特定支持Bezier轮廓的字体驱动通过FT_Outline可以提供他自己的hinter，或依赖FT的autohinter模块。&nbsp;<br><br>* 助手模块，用来处理一些共享代码，通常被多个字体驱动，甚至是其他模块使用，缺省的助手如下&nbsp;<br><br>sfnt 用来支持基于SFNT存储纲要的字体格式，TrueType和OpenType字体和其他变种&nbsp;<br><br>psnames 用来提供有关字形名称排序和Postscript编码/字符集的函数。例如他可以从一个Type1字形名称字典中自动合成一个Unicode字符图。&nbsp;<br><br>psaux 用来提供有关Type1字符解码的函数，type1、cid和cff都需要这个特性&nbsp;<br><br><br>* 最后，autohinter模块在FT中是特殊角色，当一个字体驱动没有提供自己的hint引擎时，他可以在字形装载时处理各自的字形轮廓。&nbsp;<br><br>我们现在来学习模块是如何描述以及如何被FreeType2库管理的。&nbsp;<br>1 FT_Module_Class结构&nbsp;<br><br><br>2 FT_Module类型&nbsp;<br><br></span></td>
<td><ins><ins id="google_ads_frame4_anchor"></ins></ins></td>
</tr>
<tr>
<td colspan="2">
<div>----</div>
<div>良好的沟通能力 和 积极的行动 是成功的钥匙。</div>
</td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592190&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
</tbody>
</table>
<a name="article592188"></a>
<table border="0">
<tbody>
<tr>
<td colspan="2"><span><span>Subject</span>:&nbsp;<span>[精华] FreeType 2开发文档 [中译版]</span></span>&nbsp;<br><span><span>Author</span>:&nbsp;<span><a href="http://www.linuxforum.net/forum/showprofile.php?User=gogoliu&amp;What=kylix" target="_blank">gogoliu</a></span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Posted</span>:&nbsp;<span>2006-01-23 19:18</span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Length</span>:&nbsp;<span>492</span>&nbsp;byte(s)</span></td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592188&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
<tr>
<td><span>下面3份文档是<a href="http://www.freetype.org/freetype2/documentation.html" target="_blank">FreeType 2文档</a>的 中译版，包括《FreeType Glyph Conventions》、《The design of FreeType 2》、和《The FreeType 2 Tutorial》。其中，前两者是在网上找到的，译者不详，并且有些部分没有翻译。我翻译了第三份文档的第一部分，由于翻译水平低，翻译得很死板、机 械，大家凑合着看。第二部分要是没人翻译的话，我会在年后翻译。这3份文档的中译版都有待完善，希望有空余时间和能力的朋友可以帮忙完善它们。</span></td>
<td><br></td>
</tr>
<tr>
<td colspan="2">
<div>----</div>
<div>良好的沟通能力 和 积极的行动 是成功的钥匙。</div>
</td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592188&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
</tbody>
</table>
<a name="article592191"></a>
<table border="0">
<tbody>
<tr>
<td colspan="2"><span><span>Subject</span>:&nbsp;<span>[精华] Re: FreeType 2开发文档 [中译版]</span></span>&nbsp;<br><span><span>Author</span>:&nbsp;<span><a href="http://www.linuxforum.net/forum/showprofile.php?User=gogoliu&amp;What=kylix" target="_blank">gogoliu</a></span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Posted</span>:&nbsp;<span>2006-01-23 19:18</span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Length</span>:&nbsp;<span>25,574</span>&nbsp;byte(s)</span></td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592191&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
<tr>
<td><span>《The FreeType 2 Tutorial》第一部分中译版&nbsp;<br><br><strong>FreeType 2 教程</strong>&nbsp;<br><br><strong>第一步 －－ 简易的字形装载</strong>&nbsp;<br><br><strong>介绍</strong>&nbsp;<br><br>这是“FreeType2 教程”的第一部分。它将教会你如何：&nbsp;<br><br>* 初始化库&nbsp;<br>* 通过创建一个新的 face 对象来打开一个字体文件&nbsp;<br>* 以点或者象素的形式选择一个字符大小&nbsp;<br>* 装载一个字形(glyph)图像，并把它转换为位图&nbsp;<br>* 渲染一个简单的字符串&nbsp;<br>* 容易地渲染一个旋转的字符串&nbsp;<br><br><strong>1.头文件</strong>&nbsp;<br><br>下面的内容是编译一个使用了FreeType2库的应用程序所需要的指令。请谨慎阅读，自最近一次版本更新后我们已经更改了少许东西。&nbsp;<br><br><strong>1.FreeType2 include 目录</strong>&nbsp;<br><br>你必须把FreeType2头文件的目录添加到编译包含(include)目录中。&nbsp;<br><br>注意，现在在Unix系统，你可以运行freetype-config脚本加上--cflags选项来获得正确的编译标记。这个脚本也可以用来检查安装在你系统中的库的版本，以及需要的库和连接标记。&nbsp;<br><br><strong>2. 包含名为ft2build.h的文件</strong>&nbsp;<br><br>Ft2build.h包含了接下来要#include的公共FreeType2头文件的宏声明。&nbsp;<br><br><strong>3. 包含主要的FreeType2 API头文件</strong>&nbsp;<br><br>你要使用FT_FREETYPE_H宏来完成这个工作，就像下面这样：&nbsp;<br><br>#include &lt;ft2build.h&gt;&nbsp;<br>#include FT_FREETYPE_H&nbsp;<br><br>FT_FREETYPE_H是在ftheader.h中定义的一个特别的宏。Ftheader.h包含了一些安装所特定的宏，这些宏指名了FreeType2 API的其他公共头文件。&nbsp;<br><br>你可以阅读“FreeType 2 API参考”的这个部分来获得头文件的完整列表。&nbsp;<br><br>＃include语句中宏的用法是服从ANSI的。这有几个原因：&nbsp;<br><br>* 这可以避免一些令人痛苦的与FreeType 1.x公共头文件的冲突。&nbsp;<br><br>* 宏名字不受限于DOS的8.3文件命名限制。象FT_MULTIPLE_MASTERS_H或FT_SFNT_NAMES_H这样的名字比真实的文件名ftmm.h和fsnames.h更具可读性并且更容易理解。&nbsp;<br><br>* 它允许特别的安装技巧，我们不在这里讨论它。&nbsp;<br><br>注意：从FreeType 2.1.6开始，旧式的头文件包含模式将不会再被支持。这意味着现在如果你做了象下面那样的事情，你将得到一个错误：&nbsp;<br><br>#include &lt;freetype/freetype.h&gt;&nbsp;<br>#include &lt;freetype/ftglyph.h&gt;&nbsp;<br>. . .&nbsp;<br><br><strong>2. 初始化库</strong>&nbsp;<br><br>简单地创建一个FT_Library类型的变量，例如library，然后象下面那样调用函数FT_Init_FreeType：&nbsp;<br><br>#include &lt;ft2build.h&gt;&nbsp;<br>#include FT_FREETYPE_H&nbsp;<br><br>FT_LIBRARY library;&nbsp;<br><br>. . .&nbsp;<br><br>Error = FT_Init_FreeType ( &amp;library );&nbsp;<br>If ( error )&nbsp;<br>{&nbsp;<br>. . . 当初始化库时发生了一个错误 . . .&nbsp;<br>}&nbsp;<br><br>这个函数负责下面的事情：&nbsp;<br><br>* 它创建一个FreeType 2库的新实例，并且设置句柄library为它。&nbsp;<br><br>* 它装载库中FreeType所知道的每一个模块。除了别的以外，你新建的library对象可以优雅地处理TrueType, Type 1, CID-keyed 和OpenType/CFF字体。&nbsp;<br><br>就像你所看到的，这个函数返回一个错误代码，如同FreeType API的大部分其他函数一样。值为0的错误代码始终意味着操作成功了，否则，返回值指示错误，library设为NULL。&nbsp;<br><br><strong>3．装载一个字体face</strong>&nbsp;<br><br><strong>a.从一个字体文件装载</strong>&nbsp;<br><br>应用程序通过调用FT_New_Face创建一个新的face对象。一个face对象描述了一个特定的字样和风格。例如，’Times New Roman Regular’和’Times New Roman Italic’对应两个不同的face。&nbsp;<br><br>FT_Library library; /* 库的句柄 */&nbsp;<br>FT_Face face; /* face对象的句柄 */&nbsp;<br><br>error = FT_Init_FreeType( &amp;library );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>error = FT_New_Face( library,&nbsp;<br>"/usr/share/fonts/truetype/arial.ttf",&nbsp;<br>0,&nbsp;<br>&amp;face );&nbsp;<br>if ( error == FT_Err_Unknown_File_Format )&nbsp;<br>{&nbsp;<br>... 可以打开和读这个文件，但不支持它的字体格式&nbsp;<br>}&nbsp;<br>else if ( error )&nbsp;<br>{&nbsp;<br>... 其它的错误码意味着这个字体文件不能打开和读，或者简单的说它损坏了...&nbsp;<br>}&nbsp;<br><br>就如你所想到的，FT_NEW_Face打开一个字体文件，然后设法从中提取一个face。它的参数为：<br><br>Library&nbsp;<br>一个FreeType库实例的句柄，face对象从中建立&nbsp;<br><br>Filepathname&nbsp;<br>字体文件路径名（一个标准的C字符串）&nbsp;<br><br>Face_index&nbsp;<br>某些字体格式允许把几个字体face嵌入到同一个文件中。&nbsp;<br>这个索引指示你想装载的face。&nbsp;<br>如果这个值太大，函数将会返回一个错误。Index 0总是正确的。&nbsp;<br><br>Face&nbsp;<br>一个指向新建的face对象的指针。&nbsp;<br>当失败时其值被置为NULL。&nbsp;<br><br>要知道一个字体文件包含多少个face，只要简单地装载它的第一个face(把face_index设置为0)，face-&gt;num_faces的值就指示出了有多少个face嵌入在该字体文件中。&nbsp;<br><br><strong>b.从内存装载</strong>&nbsp;<br><br>如果你已经把字体文件装载到内存，你可以简单地使用FT_New_Memory_Face为它新建一个face对象，如下所示：&nbsp;<br><br>FT_Library library; /* 库的句柄 */&nbsp;<br>FT_Face face; /* face对象的句柄 */&nbsp;<br><br><br>error = FT_Init_FreeType( &amp;library );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>error = FT_New_Memory_Face( library,&nbsp;<br>buffer, /* 缓存的第一个字节 */&nbsp;<br>size, /* 缓存的大小（以字节表示） */&nbsp;<br>0, /* face索引 */&nbsp;<br>&amp;face );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>如你所看到的，FT_New_Memory_Face简单地用字体文件缓存的指针和它的大小（以字节计算）代替文件路径。除此之外，它与FT_New_Face的语义一致。&nbsp;<br><br><strong>c.从其他来源装载（压缩文件，网络，等）</strong>&nbsp;<br><br>使用文件路径或者预装载文件到内存是简单的，但还不足够。FreeType 2可以支持通过你自己实现的I/O程序来装载文件。&nbsp;<br><br>这是通过FT_Open_Face函数来完成的。FT_Open_Face可以实现使用一个自定义的输入流，选择一个特定的驱动器来打开，乃至当创建该对象时传递外部参数给字体驱动器。我们建议你查阅“FreeType 2参考手册”，学习如何使用它。&nbsp;<br><br><strong>4．访问face内容</strong>&nbsp;<br><br>一个face对象包含该face的全部全局描述信息。通常的，这些数据可以通过分别查询句柄来直接访问，例如face-&gt;num_glyphs。&nbsp;<br><br>FT_FaceRec结构描述包含了可用字段的完整列表。我们在这里详细描述其中的某些：&nbsp;<br><br>Num_glyphs	<br>这个值给出了该字体face中可用的字形(glyphs)数目。简单来说，一个字形就是一个字符图像。但它不一定符合一个字符代码。&nbsp;<br><br>Flags&nbsp;<br>一个32位整数，包含一些用来描述face特性的位标记。例如，标记FT_FACE_FLAG_SCALABLE用来指示该face的字体格式是 可伸缩并且该字形图像可以渲染到任何字符象素尺寸。要了解face标记的更多信息，请阅读“FreeType 2 API 参考”。&nbsp;<br><br>Units_per_EM&nbsp;<br>这个字段只对可伸缩格式有效，在其他格式它将会置为0。它指示了EM所覆盖的字体单位的个数。<br><br>Num_fixed_size&nbsp;<br>这个字段给出了当前face中嵌入的位图的个数。简单来说，一个strike就是某一特定字符象素尺寸下的一系列字形图像。例如，一个字体face可以包含象素尺寸为10、12和14的strike。要注意的是即使是可伸缩的字体格式野可以包含嵌入的位图！&nbsp;<br><br>Fixed_sizes&nbsp;<br>一个指向FT_Bitmap_Size成员组成的数组的指针。每一个FT_Bitmap_Size指示face中的每一个strike的水平和垂直字符象素尺寸。&nbsp;<br>注意，通常来说，这不是位图strike的单元尺寸。&nbsp;<br><br><strong>5．设置当前象素尺寸</strong>&nbsp;<br><br>对于特定face中与字符大小相关的信息，FreeType 2使用size对象来构造。例如，当字符大小为12点时，使用一个size对象以1/64象素为单位保存某些规格（如ascender或者文字高度）的值。&nbsp;<br><br>当FT_New_Face或它的亲戚被调用，它会自动在face中新建一个size对象，并返回。该size对象可以通过face-&gt;size直接访问。&nbsp;<br><br>注意：一个face对象可以同时处理一个或多个size对象，但只有很少程序员需要用到这个功能，因而，我们决定简化该API，（例如，每个face对象只拥有一个size对象）但是这个特性我们仍然通过附加的函数提供。&nbsp;<br><br>当一个新的face对象建立时，对于可伸缩字体格式，size对象默认值为字符大小水平和垂直均为10象素。对于定长字体格式，这个大小是未定义的，这就是你必须在装载一个字形前设置该值的原因。&nbsp;<br><br>使用FT_Set_Char_Size完成该功能。这里有一个例子，它在一个300x300dpi设备上把字符大小设置为16pt。&nbsp;<br><br>error = FT_Set_Char_Size(&nbsp;<br>face, /* face对象的句柄 */&nbsp;<br>0, /* 以1/64点为单位的字符宽度 */&nbsp;<br>16*64, /* 以1/64点为单位的字符高度 */&nbsp;<br>300, /* 设备水平分辨率 */&nbsp;<br>300 ); /* 设备垂直分辨率 */&nbsp;<br><br>注意：&nbsp;<br><br>* 字符宽度和高度以1/64点为单位表示。一个点是一个1/72英寸的物理距离。通常，这不等于一个象素。&nbsp;<br><br>* 设备的水平和垂直分辨率以每英寸点数(dpi)为单位表示。显示设备（如显示器）的常规值为72dpi或96dpi。这个分辨率是用来从字符点数计算字符象素大小的。&nbsp;<br><br>* 字符宽度为0意味着“与字符高度相同”，字符高度为0意味着“与字符宽度相同”。对于其他情况则意味着指定不一样的字符宽度和高度。&nbsp;<br><br>* 水平或垂直分辨率为0时表示使用默认值72dpi。&nbsp;<br><br>* 第一个参数是face对象的句柄，不是size对象的。&nbsp;<br><br>这个函数计算对应字符宽度、高度和设备分辨率的字符象素大小。然而，如果你想自己指定象素大小，你可以简单地调用FT_Set_Pixel_Sizes，就像这样：&nbsp;<br><br>error = FT_Set_Pixel_Sizes(&nbsp;<br>face, /* face对象句柄 */&nbsp;<br>0, /* 象素宽度 */&nbsp;<br>16 ); /* 象素高度 */&nbsp;<br><br>这个例子把字符象素设置为16x16象素。如前所说的，尺寸中的任一个为0意味着“与另一个尺寸值相等”。&nbsp;<br><br>注意这两个函数都返回错误码。通常，错误会发生在尝试对定长字体格式（如FNT或PCF）设置不在face-&gt;fixed_size数组中的象素尺寸值。&nbsp;<br><br><strong>6．装载一个字形图像</strong>&nbsp;<br><br><strong>a.把一个字符码转换为一个字形索引</strong>&nbsp;<br><br>通常，一个应用程序想通过字符码来装载它的字形图像。字符码是一个特定编码中代表该字符的数值。例如，字符码64代表了ASCII编码中的’A’。&nbsp;<br><br>一个face对象包含一个或多个字符表(charmap)，字符表是用来转换字符码到字形索引的。例如，很多TrueType字体包含两个字符 表，一个用来转换Unicode字符码到字形索引，另一个用来转换Apple Roman编码到字形索引。这样的字体既可以用在Windows（使用Unicode）和Macintosh（使用Apple Roman）。同时要注意，一个特定的字符表可能没有覆盖完字体里面的全部字形。&nbsp;<br><br>当新建一个face对象时，它默认选择Unicode字符表。如果字体没包含Unicode字符表，FreeType会尝试在字形名的基础上模拟 一个。注意，如果字形名是不标准的那么模拟的字符表有可能遗漏某些字形。对于某些字体，包括符号字体和旧的亚洲手写字体，Unicode模拟是不可能的。&nbsp;<br><br>我们将在稍后叙述如何寻找face中特定的字符表。现在我们假设face包含至少一个Unicode字符表，并且在调用FT_New_Face时已经被选中。我们使用FT_Get_Char_Index把一个Unicode字符码转换为字形索引，如下所示：&nbsp;<br><br>glyph_index = FT_Get_Char_Index( face, charcode );&nbsp;<br><br>这个函数会在face里被选中的字符表中查找与给出的字符码对应的字形索引。如果没有字符表被选中，这个函数简单的返回字符码。&nbsp;<br><br>注意，这个函数是FreeType中罕有的不返回错误码的函数中的一个。然而，当一个特定的字符码在face中没有字形图像，函数返回0。按照约定，它对应一个特殊的字形图像――缺失字形，通常会显示一个框或一个空格。&nbsp;<br><br><strong>b.从face中装载一个字形</strong>&nbsp;<br><br>一旦你获得了字形索引，你便可以装载对应的字形图像。在不同的字体中字形图像存储为不同的格式。对于固定尺寸字体格式，如FNT或者PCF，每一 个图像都是一个位图。对于可伸缩字体格式，如TrueType或者Type1，使用名为轮廓(outlines)的矢量形状来描述每一个字形。一些字体格 式可能有更特殊的途径来表示字形（如MetaFont――但这个格式不被支持）。幸运的，FreeType2有足够的灵活性，可以通过一个简单的API支 持任何类型的字形格式。&nbsp;<br><br>字形图像存储在一个特别的对象――字形槽(glyph slot)中。就如其名所暗示的，一个字形槽只是一个简单的容器，它一次只能容纳一个字形图像，可以是位图，可以是轮廓，或者其他。每一个face对象都 有一个字形槽对象，可以通过face-&gt;glyph来访问。它的字段在FT_GlyphSlotRec结构的文档中解释了。&nbsp;<br><br>通过调用FT_Load_Glyph来装载一个字形图像到字形槽中，如下：&nbsp;<br><br>error = FT_Load_Glyph(&nbsp;<br>face, /* face对象的句柄 */&nbsp;<br>glyph_index, /* 字形索引 */&nbsp;<br>load_flags ); /* 装载标志，参考下面 */&nbsp;<br><br>load_flags的值是位标志集合，是用来指示某些特殊操作的。其默认值是FT_LOAD_DEFAULT即0。&nbsp;<br><br>这个函数会设法从face中装载对应的字形图像：&nbsp;<br><br>* 如果找到一个对应该字形和象素尺寸的位图，那么它将会被装载到字形槽中。嵌入的位图总是比原生的图像格式优先装载。因为我们假定对一个字形，它有更高质量的版本。这可以用FT_LOAD_NO_BITMAP标志来改变。&nbsp;<br><br>* 否则，将装载一个该字形的原生图像，把它伸缩到当前的象素尺寸，并且对应如TrueType和Type1这些格式，也会完成hinted操作。&nbsp;<br><br>字段face-&gt;glyph-&gt;format描述了字形槽中存储的字形图像的格式。如果它的值不是FT_GLYPH_FORMAT_BITMAP，你可以通过FT_Render_Glyph把它直接转换为一个位图。如下：&nbsp;<br><br>error = FT_Render_Glyph( face-&gt;glyph, /* 字形槽 */&nbsp;<br>render_mode ); /* 渲染模式 */&nbsp;<br><br>render_mode参数是一个位标志集合，用来指示如何渲染字形图像。把它设为FT_RENDER_MODE_NORMAL渲染出一个高质量的抗锯齿(256级灰度)位图。这是默认情况，如果你想生成黑白位图，可以使用FT_RENDER_MODE_MONO标志。&nbsp;<br><br>一旦你生成了一个字形图像的位图，你可以通过glyph-&gt;bitmap(一个简单的位图描述符)直接访问，同时用glyph-&gt;bitmap_left和glyph-&gt;bitmap_top来指定起始位置。&nbsp;<br><br>要注意，bitmap_left是从字形位图当前笔位置到最左边界的水平距离，而bitmap_top是从笔位置（位于基线）到最高边界得垂直距离。他么是正数，指示一个向上的距离。&nbsp;<br><br>下一部分将给出字形槽内容的更多细节，以及如何访问特定的字形信息（包括度量）。&nbsp;<br><br><strong>c.使用其他字符表</strong>&nbsp;<br><br>如前面所说的，当一个新face对象创建时，它会寻找一个Unicode字符表并且选择它。当前被选中的字符表可以通过 face-&gt;charmap访问。当没有字符表被选中时，该字段为NULL。这种情况在你从一个不含Unicode字符表的字体文件（这种文件现在 非常罕见）创建一个新的FT_Face对象时发生。&nbsp;<br><br>有两种途径可以在FreeType 2中选择不同的字符表。最轻松的途径是你所需的编码已经有对应的枚举定义在FT_FREETYPE_H中，例如FT_ENCODING_BIG5。在这种情况下，你可以简单地调用FT_Select_CharMap，如下：&nbsp;<br><br>error = FT_Select_CharMap(&nbsp;<br>face, /* 目标face对象 */&nbsp;<br>FT_ENCODING_BIG5 ); /* 编码 */&nbsp;<br><br>另一种途径是手动为face解析字符表。这通过face对象的字段num_charmaps和charmaps(注意这是复数)来访问。如你想到 的，前者是face中的字符表的数目，后者是一个嵌入在face中的指向字符表的指针表(a table of pointers to the charmaps)。&nbsp;<br><br>每一个字符表有一些可见的字段，用来更精确地描述它，主要用到的字段是charmap-&gt;platform_id和charmap-&gt;encoding_id。这两者定义了一个值组合，以更普&nbsp;<br>通的形式用来描述该字符表。&nbsp;<br><br>每一个值组合对应一个特定的编码。例如组合(3,1)对应Unicode。组合列表定义在TrueType规范中，但你也可以使用文件FT_TRUETYPE_IDS_H来处理它们，该文件定义了几个有用的常数。&nbsp;<br><br>要选择一个具体的编码，你需要在规范中找到一个对应的值组合，然后在字符表列表中寻找它。别忘记，由于历史的原因，某些编码会对应几个值组合。这里是一些代码：&nbsp;<br><br>FT_CharMap found = 0;&nbsp;<br>FT_CharMap charmap;&nbsp;<br>int n;&nbsp;<br><br><br>for ( n = 0; n &lt; face-&gt;num_charmaps; n++ )&nbsp;<br>{&nbsp;<br>charmap = face-&gt;charmaps[n];&nbsp;<br>if ( charmap-&gt;platform_id == my_platform_id &amp;&amp;&nbsp;<br>charmap-&gt;encoding_id == my_encoding_id )&nbsp;<br>{&nbsp;<br>found = charmap;&nbsp;<br>break;&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>if ( !found ) { ... }&nbsp;<br><br>/* 现在，选择face对象的字符表*/&nbsp;<br>error = FT_Set_CharMap( face, found );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>一旦某个字符表被选中，无论通过FT_Select_CharMap还是通过FT_Set_CharMap，它都会在后面的FT_Get_Char_Index调用使用。&nbsp;<br><br><strong>d.字形变换</strong>&nbsp;<br><br>当字形图像被装载时，可以对该字形图像进行仿射变换。当然，这只适用于可伸缩（矢量）字体格式。&nbsp;<br><br>简单地调用FT_Set_Transform来完成这个工作，如下：&nbsp;<br><br>error = FT_Set_Transform(&nbsp;<br>face, /* 目标face对象 */&nbsp;<br>&amp;matrix, /* 指向2x2矩阵的指针 */&nbsp;<br>&amp;delta ); /* 指向2维矢量的指针 */&nbsp;<br><br>这个函数将对指定的face对象设置变换。它的第二个参数是一个指向FT_Matrix结&nbsp;<br>构的指针。该结构描述了一个2x2仿射矩阵。第三个参数是一个指向FT_Vector结构的指针。该结构描述了一个简单的二维矢量。该矢量用来在2x2变换后对字形图像平移。&nbsp;<br><br>注意，矩阵指针可以设置为NULL，在这种情况下将进行恒等变换。矩阵的系数是16.16形式的固定浮点单位。&nbsp;<br><br>矢量指针也可以设置为NULL，在这种情况下将使用(0, 0)的delta。矢量坐标以一个象素的1/64为单位表示（即通常所说的26.6固定浮点格式）。&nbsp;<br><br>注意：变换将适用于使用FT_Load_Glyph装载的全部字形，并且完全独立于任何hinting处理。这意味着你对一个12象素的字形进行2倍放大变换不会得到与24象素字形相同的结果（除非你禁止hints）。&nbsp;<br><br>如果你需要使用非正交变换和最佳hints，你首先必须把你的变换分解为一个伸缩部分和一个旋转/剪切部分。使用伸缩部分来计算一个新的字符象素大小，然后使用旋转/剪切部分来调用FT_Set_Transform。这在本教程的后面部分有详细解释。&nbsp;<br><br>同时要注意，对一个字形位图进行非同一性变换将产生错误。&nbsp;<br><br><strong>7. 简单的文字渲染</strong>&nbsp;<br><br>现在我们将给出一个非常简单的例子程序，该例子程序渲染一个8位Latin-1文本字符串，并且假定face包含一个Unicode字符表。&nbsp;<br><br>该程序的思想是建立一个循环，在该循环的每一次迭代中装载一个字形图像，把它转换为一个抗锯齿位图，把它绘制到目标表面(surface)上，然后增加当前笔的位置。&nbsp;<br><br><strong>a.基本代码</strong>&nbsp;<br><br>下面的代码完成我们上面提到的简单文本渲染和其他功能。&nbsp;<br><br>FT_GlyphSlot slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br>int pen_x, pen_y, n;&nbsp;<br><br><br>... initialize library ...&nbsp;<br>... create face object ...&nbsp;<br>... set character size ...&nbsp;<br><br>pen_x = 300;&nbsp;<br>pen_y = 200;&nbsp;<br><br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>FT_UInt glyph_index;&nbsp;<br><br><br>/* 从字符码检索字形索引 */&nbsp;<br>glyph_index = FT_Get_Char_Index( face, text[n] );&nbsp;<br><br>/* 装载字形图像到字形槽（将会抹掉先前的字形图像） */&nbsp;<br>error = FT_Load_Glyph( face, glyph_index, FT_LOAD_DEFAULT );&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误 */&nbsp;<br><br>/* 转换为一个抗锯齿位图 */&nbsp;<br>error = FT_Render_Glyph( face-&gt;glyph, ft_render_mode_normal );&nbsp;<br>if ( error )&nbsp;<br>continue;&nbsp;<br><br>/* 现在，绘制到我们的目标表面(surface) */&nbsp;<br>my_draw_bitmap( &amp;slot-&gt;bitmap,&nbsp;<br>pen_x + slot-&gt;bitmap_left,&nbsp;<br>pen_y - slot-&gt;bitmap_top );&nbsp;<br><br>/* 增加笔位置 */&nbsp;<br>pen_x += slot-&gt;advance.x &gt;&gt; 6;&nbsp;<br>pen_y += slot-&gt;advance.y &gt;&gt; 6; /* 现在还是没用的 */&nbsp;<br>}&nbsp;<br><br>这个代码需要一些解释：&nbsp;<br><br>* 我们定义了一个名为slot的句柄，它指向face对象的字形槽。（FT_GlyphSlot类型是一个指针）。这是为了便于避免每次都使用face-&gt;glyph-&gt;XXX。&nbsp;<br><br>* 我们以slot-&gt;advance增加笔位置，slot-&gt;advance符合字形的步进宽度（也就是通常所说的走格(escapement)）。步进矢量以象素的1/64为单位表示，并且在每一次迭代中删减为整数象素。&nbsp;<br><br>* 函数my_draw_bitmap不是FreeType的一部分，但必须由应用程序提供以用来绘制位图到目标表面。在这个例子中，该函数以一个FT_Bitmap描述符的指针和它的左上角位置为参数。&nbsp;<br><br>* Slot-&gt;bitmap_top的值是正数，指字形图像顶点与pen_y的垂直距离。我们假定my_draw_bitmap采用的坐标使用一样的约定（增加Y值对应向下的扫描线）。我们用pen_y减它，而不是加它。&nbsp;<br><br><strong>b.精练的代码</strong>&nbsp;<br><br>下面的代码是上面例子程序的精练版本。它使用了FreeType 2中我们还没有介绍的特性和函数，我们将在下面解释：&nbsp;<br><br>FT_GlyphSlot slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br>FT_UInt glyph_index;&nbsp;<br>int pen_x, pen_y, n;&nbsp;<br><br><br>... initialize library ...&nbsp;<br>... create face object ...&nbsp;<br>... set character size ...&nbsp;<br><br>pen_x = 300;&nbsp;<br>pen_y = 200;&nbsp;<br><br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>/* 装载字形图像到字形槽（将会抹掉先前的字形图像） */&nbsp;<br>error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误 */&nbsp;<br><br>/* 现在，绘制到我们的目标表面(surface) */&nbsp;<br>my_draw_bitmap( &amp;slot-&gt;bitmap,&nbsp;<br>pen_x + slot-&gt;bitmap_left,&nbsp;<br>pen_y - slot-&gt;bitmap_top );&nbsp;<br><br>/* 增加笔位置 */&nbsp;<br>pen_x += slot-&gt;advance.x &gt;&gt; 6;&nbsp;<br>}&nbsp;<br><br>我们简化了代码的长度，但它完成相同的工作：&nbsp;<br><br>* 我们使用函数FT_Loac_Char代替FT_Load_Glyph。如你大概想到的，它相当于先调用GT_Get_Char_Index然后调用FT_Get_Load_Glyph。&nbsp;<br><br>* 我们不使用FT_LOAD_DEFAULT作为装载模式，使用FT_LOAD_RENDER。它指示了字形图像必须立即转换为一个抗锯齿位图。这是一个捷径，可以取消明显的调用FT_Render_Glyph，但功能是相同的。&nbsp;<br>注意，你也可以指定通过附加FT_LOAD_MONOCHROME装载标志来获得一个单色位图。&nbsp;<br><br><strong>c.更高级的渲染</strong>&nbsp;<br><br>现在，让我们来尝试渲染变换文字（例如通过一个环）。我们可以用FT_Set_Transform来完成。这里是示例代码：&nbsp;<br><br>FT_GlyphSlot slot;&nbsp;<br>FT_Matrix matrix; /* 变换矩阵 */&nbsp;<br>FT_UInt glyph_index;&nbsp;<br>FT_Vector pen; /* 非变换原点 */&nbsp;<br>int n;&nbsp;<br><br><br>... initialize library ...&nbsp;<br>... create face object ...&nbsp;<br>... set character size ...&nbsp;<br><br>slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br><br>/* 准备矩阵 */&nbsp;<br>matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );&nbsp;<br>matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );&nbsp;<br>matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );&nbsp;<br>matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );&nbsp;<br><br>/* 26.6 笛卡儿空间坐标中笔的位置，以(300, 200)为起始 */&nbsp;<br>pen.x = 300 * 64;&nbsp;<br>pen.y = ( my_target_height - 200 ) * 64;&nbsp;<br><br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>/* 设置变换 */&nbsp;<br>FT_Set_Transform( face, &amp;matrix, &amp;pen );&nbsp;<br><br>/* 装载字形图像到字形槽（将会抹掉先前的字形图像） */&nbsp;<br>error = FT_Load_Char( face, text[n], FT_LOAD_RENDER );&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误 */&nbsp;<br><br>/* 现在，绘制到我们的目标表面（变换位置） */&nbsp;<br>my_draw_bitmap( &amp;slot-&gt;bitmap,&nbsp;<br>slot-&gt;bitmap_left,&nbsp;<br>my_target_height - slot-&gt;bitmap_top );&nbsp;<br><br>/* 增加笔位置 */&nbsp;<br>pen.x += slot-&gt;advance.x;&nbsp;<br>pen.y += slot-&gt;advance.y;&nbsp;<br>}&nbsp;<br><br>一些说明：&nbsp;<br><br>* 现在我们使用一个FT_Vector类型的矢量来存储笔位置，其坐标以象素的1/64为单位表示，并且倍增。该位置表示在笛卡儿空间。&nbsp;<br><br>* 不同于系统典型的对位图使用的坐标系（其最高的扫描线是坐标0），FreeType中，字形图像的装载、变换和描述总是采用笛卡儿坐标系（这意味着增加Y对应向上的扫描线）。因此当我们定义笔位置和计算位图左上角时必须在两个系统之间转换。&nbsp;<br><br>* 我们对每一个字形设置变换来指示旋转矩阵以及使用一个delta来移动转换后的图像到当前笔位置（在笛卡儿空间，不是位图空间）。结 果，bitmap_left和bitmap_top的值对应目标空间象素中的位图原点。因此，我们在调用my_draw_bitmap时不在它们的值上加 pen.x或pen.y。&nbsp;<br><br>* 步进宽度总会在变换后返回，这就是它可以直接加到当前笔位置的原因。注意，这次它不会四舍五入。&nbsp;<br><br>一个例子完整的源代码可以在这里找到。&nbsp;<br><br>要很注意，虽然这个例子比前面的更复杂，但是变换效果是完全一致的。因此它可以作为一个替换（但更强大）。&nbsp;<br><br>然而该例子有少许缺点，我们将在本教程的下一部分中解释和解决。&nbsp;<br><br><strong>结论</strong>&nbsp;<br><br>在这个部分，你已经学习了FreeType2的基础以及渲染旋转文字的充分知识。&nbsp;<br><br>下一部分将深入了解FreeType 2 API更详细的资料，它可以让你直接访问字形度量标准和字形图像，还能让你学习到如何处理缩放、hinting、自居调整，等等。&nbsp;<br><br>第三部分将讨论模块、缓存和其他高级主题，如如何在一个face中使用多个尺寸对象。【这部分还没有编写】</span></td>
<td>
<table border="0">
<tbody>
<tr>
<td><ins><ins id="google_ads_frame5_anchor"></ins></ins></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr>
<td colspan="2">
<div>----</div>
<div>良好的沟通能力 和 积极的行动 是成功的钥匙。</div>
</td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=592191&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
</tbody>
</table>
<a name="article599560"></a>
<table border="0">
<tbody>
<tr>
<td colspan="2"><span><span>Subject</span>:&nbsp;<span>Re: FreeType 2开发文档 [中译版]</span></span>&nbsp;<br><span><span>Author</span>:&nbsp;<span><a href="http://www.linuxforum.net/forum/showprofile.php?User=gogoliu&amp;What=kylix" target="_blank">gogoliu</a></span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Posted</span>:&nbsp;<span>2006-03-13 23:39</span></span>&nbsp;&nbsp;&nbsp;&nbsp;<span><span>Length</span>:&nbsp;<span>37,333</span>&nbsp;byte(s)</span></td>
</tr>
<tr>
<td colspan="2"><span>[<a href="http://www.linuxforum.net/forum/showthreaded.php?Cat=&amp;Board=kylix&amp;Number=599560&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0" target="_blank">Original</a>]</span>&nbsp;<span>[Print]</span>&nbsp;<span><a href="http://www.unixresources.net/linux/clf/kylix/archive/00/00/59/21/592188.html#top">[Top]</a></span></td>
</tr>
<tr>
<td><span>《The FreeType 2 Tutorial》第二部分中译版&nbsp;<br><br><strong>FreeType 2 教程</strong>&nbsp;<br><br><strong>第二步 －－ 管理字形</strong>&nbsp;<br><br><strong>介绍</strong>&nbsp;<br><br>这是“FreeType2 教程”的第二部分。它将教会你如何：&nbsp;<br><br>* 检索字形度量&nbsp;<br>* 容易地管理字形图像&nbsp;<br>* 检索全局度量（包括字距调整）&nbsp;<br>* 渲染一个简单的字符串（采用字距调整）&nbsp;<br>* 渲染一个居中的字符串（采用字距调整）&nbsp;<br>* 渲染一个变换的字符串（采用居中）&nbsp;<br>* 在需要时以预设字体单位的格式获取度量，以及把它们缩放到设备空间&nbsp;<br><br><strong>1.字形度量</strong>&nbsp;<br><br>从字形度量这个名字可以想到，字形度量是关联每一个字形的确定距离，以此描述如何使用该距离来排版文本。&nbsp;<br><br>通常一个字形有两个度量集：用来排版水平文本排列的字形（拉丁文、西里尔文、阿拉伯文、希伯来文等等）和用来排版垂直文本排列的字形（中文、日文、韩文等等）。&nbsp;<br><br>要注意的是只有很少的字体格式提供了垂直度量。你可以使用宏FT_HAS_VERTICAL测试某个给出的face对象是否包含垂直度量，当结果为真时表示包含。&nbsp;<br><br>个别的字形度量可以先装载字形到face的字形槽，然后通过face-&gt;glyph-&gt;metrics结构访问，其类型为FT_Glyph_Metrics。我们将在下面详细讨论它，现在，我们只关注该结构包含如下的字段：&nbsp;<br><br>Width&nbsp;<br>这是字形图像的边框的宽度。它与排列方向无关。&nbsp;<br><br>Height&nbsp;<br>这是字形图像的边框的高度。它与排列方向无关。&nbsp;<br><br>horiBearingX&nbsp;<br>用于水平文本排列，这是从当前光标位置到字形图像最左边的边界的水平距离。&nbsp;<br><br>horiBearingY&nbsp;<br>用于水平文本排列，这是从当前光标位置（位于基线）到字形图像最上边的边界的水平距离。&nbsp;<br><br>horiAdvance&nbsp;<br>用于水平文本排列，当字形作为字符串的一部分被绘制时，这用来增加笔位置的水平距离。&nbsp;<br><br>vertBearingX&nbsp;<br>用于垂直文本排列，这是从当前光标位置到字形图像最左边的边框的垂直距离。&nbsp;<br><br>vertBearingY&nbsp;<br>用于垂直文本排列，这是从当前光标位置（位于基线）到字形图像最上边的边框的垂直距离。&nbsp;<br><br>vertAdvance&nbsp;<br>用于垂直文本排列，当字形作为字符串的一部分被绘制时，这用来增加笔位置的垂直距离。&nbsp;<br><br>注意：因为不是所有的字体都包含垂直度量，当FT_HAS_VERTICAL为假时，vertBearingX，vertBearingY和vertAdvance的值是不可靠的。&nbsp;<br><br>下面的图形更清楚地图解了度量。第一个图解了水平度量，其基线为水平轴：&nbsp;<br><img title="freetype2 开发手册 - Jesse Rei - Jesse Rei 的博客 步入..." src="./FreeType2中文手册_files/metrics.png" alt="freetype2 开发手册 - Jesse Rei - Jesse Rei 的博客 步入...">&nbsp;<br><br>对于垂直文本排列，基线是垂直的，与垂直轴一致：&nbsp;<br><img title="freetype2 开发手册 - Jesse Rei - Jesse Rei 的博客 步入..." src="./FreeType2中文手册_files/metrics2.png" alt="freetype2 开发手册 - Jesse Rei - Jesse Rei 的博客 步入...">&nbsp;<br><br>Face-&gt;glyph-&gt;metrics中的度量通常以26.6象素格式（例如1/64象素）表示，除非你在调用FT_Load_Glyph或FT_Load_Char时使用了FT_LOAD_NO_SCALE标志，这样的话度量会用原始字体单位表示。&nbsp;<br><br>字形槽(glyph slot)对象也有一些其他有趣的字段可以减轻开发者的工作。你可以通过face-&gt;glyph-&gt;xxx访问它们，其中xxx是下面字段之一：&nbsp;<br><br>Advance&nbsp;<br>这个字段是一个FT_Vector，保存字形的变换推进。当你通过FT_Set_Transform使用变换时，这是很有用的，这在第一部分的循 环文本例子中已经展示过了。与那不同，这个值是默认的(metrics.horiAdvance,0)，除非你在装载字形图像时指定 FT_LOAD_VERTICAL，那么它将会为(0,metrics.vertAdvance)。&nbsp;<br><br>linearHoriAdvance&nbsp;<br>这个字段包含字形水平推进宽度的线性刻度值。实际上，字形槽返回的metrics.horiAdvance值通常四舍五入为整数象素坐标（例如， 它是64的倍数），字体驱动器用它装载字形图像。linearHoriAdvance是一个16.16固定浮点数，提供了以1/65536象素为单位的原 始字形推进宽度的值。它可以用来完成伪设备无关文字排版。&nbsp;<br><br>linearVertAdvance&nbsp;<br>这与linearHoriAdvance类似，但它用于字形的垂直推进高度。只有当字体face包含垂直度量时这个值才是可靠的。&nbsp;<br><br><strong>2.管理字形图像</strong>&nbsp;<br><br>转载到字形槽得字形图像可以转换到一幅位图中，这可以在装载时使用FT_LOAD_RENDER标志或者调用FT_Render_Glyph函数实现。每一次你装载一个新的字形图像到字形槽，前面装载的将会从字形槽中抹去。&nbsp;<br><br>但是，你可能需要从字形槽中提取这个图像，以用来在你的应用程序中缓存它，或者进行附加的变换，或者在转换到位图前测量它。&nbsp;<br><br>FreeType 2 API有一个特殊的扩展能够以一种灵活和普通的方式处理字形图像。要使用它，你首先需要包含FT_GLYPH_H头文件，如下：&nbsp;<br><br>#include FT_GLYPH_H&nbsp;<br><br>现在我们将解释如何使用这个文件定义的这个函数。&nbsp;<br><br><strong>a.提取字形图像</strong>&nbsp;<br><br>你可以很简单地提取一个字形图像。这里有一向代码向你展示如何去做：&nbsp;<br><br>FT_Glyph glyph; /* 字形图像的句柄 */&nbsp;<br><br>...&nbsp;<br>error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NORMAL );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>如你所看到的，我们：&nbsp;<br><br>* 创建一个类型为FT_Glyph，名为glyph的变量。这是一个字形图像的句柄（即指针）。&nbsp;<br><br>* 装载字形图像（通常情况下）到face的字形槽中。我们不使用FT_LOAD_RENDER因为我们想抓取一个可缩放的字形图像，以便后面对其进行变换。&nbsp;<br><br>* 通过调用FT_Get_Glyph，把字形图像从字形槽复制到新的FT_Glyph对象glyph中。这个函数返回一个错误码并且设置glyph。&nbsp;<br><br>要非常留意，被取出的字形跟字形槽中的原始字形的格式是一样的。例如，如果我们从TrueType字体文件中装载一个字形，字形图像将是可伸缩的矢量轮廓。&nbsp;<br><br>如果你想知道字形是如何模型和存储的，你可以访问flyph-&gt;format字段。一个新的字形对象可以通过调用FT_Done_Glyph来销毁。&nbsp;<br><br>字形对象正好包含一个字形图像和一个2D矢量，2D矢量以16.16固定浮点坐标的形式表示字形的推进。后者可以直接通过glyph-&gt;advance访问。&nbsp;<br><br>注意，不同于其他TrueType对象，库不保存全部分配了的字形对象的列表。这意味着你必须自己销毁它们，而不是依靠FT_Done_FreeType完成全部的清除。&nbsp;<br><br><strong>b.变换和复制字形图像</strong>&nbsp;<br><br>如果字形图像是可伸缩的（例如，如果glyph-&gt;format不等于FT_GLYPH_FORMAT_BITMAP），那么就可以随时通过调用FT_Glyph_Transform来变换该图像。&nbsp;<br><br>你也可以通过FT_Glyph_Copy复制一个字形图像。这里是一些例子代码：&nbsp;<br><br>FT_Glyph glyph, glyph2;&nbsp;<br>FT_Matrix matrix;&nbsp;<br>FT_Vector delta;&nbsp;<br><br>... 装载字形图像到 `glyph' ...&nbsp;<br><br>/* 复制 glyph 到 glyph2 */&nbsp;<br><br>error = FT_Glyph_Copy( glyph, &amp;glyph2 );&nbsp;<br>if ( error ) { ... 无法复制（内存不足） ... }&nbsp;<br><br>/* 平移 `glyph' */&nbsp;<br><br>delta.x = -100 * 64; /* 坐标是 26.6 象素格式的 */&nbsp;<br>delta.y = 50 * 64;&nbsp;<br><br>FT_Glyph_Transform( glyph, 0, &amp;delta );&nbsp;<br><br>/* 变换 glyph2 （水平剪切） */&nbsp;<br><br>matrix.xx = 0x10000L;&nbsp;<br>matrix.xy = 0.12 * 0x10000L;&nbsp;<br>matrix.yx = 0;&nbsp;<br>matrix.yy = 0x10000L;&nbsp;<br><br>FT_Glyph_Transform( glyph2, &amp;matrix, 0 );&nbsp;<br><br>注意，2x2矩阵变换总是适用于字形的16.16推进矢量，所以你不需要重修计算它。&nbsp;<br><br><strong>c.测量字形图像</strong>&nbsp;<br><br>你也可以通过FT_Glyph_Get_CBox函数检索任意字形图像（无论是可伸缩或者不可伸缩的）的控制（约束）框，如下：&nbsp;<br><br>FT_BBox bbox;&nbsp;<br><br>...&nbsp;<br>FT_Glyph_Get_CBox( glyph, bbox_mode, &amp;bbox );&nbsp;<br><br>坐标是跟字形的原点(0, 0)相关的，使用y向上的约定。这个函数取一个特殊的参数：bbox_mode来指出如何表示框坐标。&nbsp;<br><br>如果字形装载时使用了FT_LOAD_NO_SCALE标志，bbox_mode必须设置为FT_GLYPH_BBOX_UNSCALED，以此 来获得以26.6象素格式为单位表示的不可缩放字体。值FT_GLYPH_BBOX_SUBPIXELS是这个常量的另一个名字。&nbsp;<br><br>要注意，框(box)的最大坐标是唯一的，这意味着你总是可以以整数或26.6象素的形式计算字形图像的宽度和高度，公式如下：&nbsp;<br><br>width = bbox.xMax - bbox.xMin;&nbsp;<br>height = bbox.yMax - bbox.yMin;&nbsp;<br><br>同时要注意，对于26.6坐标，如果FT_GLYPH_BBOX_GRIDFIT被用作为bbox_mode，坐标也将网格对齐，符合如下公式：&nbsp;<br><br>bbox.xMin = FLOOR( bbox.xMin )&nbsp;<br>bbox.yMin = FLOOR( bbox.yMin )&nbsp;<br>bbox.xMax = CEILING( bbox.xMax )&nbsp;<br>bbox.yMax = CEILING( bbox.yMax )&nbsp;<br><br>要把bbox以整数象素坐标的形式表示，把bbox_mode设置为FT_GLYPH_BBOX_TRUNCATE。&nbsp;<br><br>最后，要把约束框以网格对齐象素坐标的形式表示，把bbox_mode设置为FT_GLYPH_BBOX_PIXELS。&nbsp;<br><br><strong>d.转换字形图像为位图</strong>&nbsp;<br><br>当你已经把字形对象缓存或者变换后，你可能需要转换它到一个位图。这可以通过FT_Glyph_To_Bitmap函数简单得实现。它负责转换任何字形对象到位图，如下：&nbsp;<br><br>FT_Vector origin;&nbsp;<br>origin.x = 32;	/* 26.6格式的1/2象素 */&nbsp;<br>origin.y = 0;&nbsp;<br>error = FT_Glyph_To_Bitmap(&nbsp;<br>&amp;glyph,&nbsp;<br>render_mode,&nbsp;<br>&amp;origin,&nbsp;<br>1 );	 /* 销毁原始图像 == true */&nbsp;<br><br>一些注解：&nbsp;<br><br>* 第一个参数是源字形句柄的地址。当这个函数被调用时，它读取该参数来访问源字形对象。调用结束后，这个句柄将指向一个新的包含渲染后的位图的字形对象。&nbsp;<br><br>* 第二个参数时一个标准渲染模式，用来指定我们想要哪种位图。它取FT_RENDER_MODE_DEFAULT时表示8位颜色深度的抗锯齿位图；它取FT_RENDER_MODE_MONO时表示1位颜色深度的黑白位图。&nbsp;<br><br>* 第三个参数是二维矢量的指针。该二维矢量是在转换前用来平移源字形图像的。要注意，函数调用后源图像将被平移回它的原始位置（这样便不会有变化）。如果你在渲染前不需要平移源字形，设置这个指针为0。&nbsp;<br><br>* 最后一个参数是一个布尔值，用来指示该函数是否要销毁源字形对象。如果为false，源字形对象不会被销毁，即使它的句柄丢失了（客户应用程序需要自己保留句柄）。&nbsp;<br><br>如果没返回错误，新的字形对象总是包含一个位图。并且你必须把它的句柄进行强制类型转换，转换为FT_BitmapGlyph类型，以此访问它的内容。这个类型是FT_Glyph的一种“子类”，它包含下面的附加字段（看FT_BitmapGlyphRec）：&nbsp;<br><br>Left&nbsp;<br>类似于字形槽的bitmap_left字段。这是字形原点(0,0)到字形位图最左边象素的水平距离。它以整数象素的形式表示。&nbsp;<br>Top&nbsp;<br>类似于字形槽的bitmap_top字段。它是字形原点(0,0)到字形位图最高象素之间的垂直距离（更精确来说，到位图上面的象素）。这个距离以整数象素的形式表示，并且y轴向上为正。&nbsp;<br>Bitmap&nbsp;<br>这是一个字形对象的位图描述符，就像字形槽的bitmap字段。&nbsp;<br><br><strong>3.全局字形度量</strong>&nbsp;<br><br>不同于字形度量，全局度量是用来描述整个字体face的距离和轮廓的。他们可以用26.6象素格式或者可缩放格式的“字体单位”来表示。&nbsp;<br><br><strong>a.预设全局度量</strong>&nbsp;<br><br>对于可缩放格式，全部全局度量都是以字体单位的格式表示的，这可以用来在稍后依照本教程本部分的最后一章描述的规则来缩放到设备空间。你可以通过FT_Face句柄的字段直接访问它们。&nbsp;<br><br>然而，你需要在使用它们前检查字体face的格式是否可缩放。你可以使用宏FT_IS_SCALEABLE来实现，当该字体是可缩放时它返回正。&nbsp;<br><br>如果是这样，你就可以访问全局预设度量了，如下：&nbsp;<br><br>units_per_EM&nbsp;<br>这是字体face的EM正方形的大小。它是可缩放格式用来缩放预设坐标到设备象素的，我们在这部分的最后一章叙述它。通常这个值为2048（对于 TrueType）或者1000（对于Type 1），但是其他值也是可能的。对于固定尺寸格式，如FNT/FON/PCF/BDF，它的值为1。&nbsp;<br><br>global_bbox&nbsp;<br>全局约束框被定义为最大矩形，该矩形可以包围字体face的所有字形。它只为水平排版而定义。&nbsp;<br><br>ascender&nbsp;<br>Ascender是从水平基线到字体face最高“字符”的坐标之间的垂直距离。不幸地，不同的字体格式对ascender的定义是不同的。对于 某些来说，它代表了全部大写拉丁字符（重音符合除外）的上沿值(ascent)；对于其他，它代表了最高的重音符号的上沿值(ascent)；最后，其他 格式把它定义为跟global_bbox.yMax相同。&nbsp;<br><br>descender&nbsp;<br>Descender是从水平基线到字体face最低“字符”的坐标之间的垂直距离。不幸地，不同的字体格式对descender的定义是不同的。 对于某些来说，它代表了全部大写拉丁字符（重音符合除外）的下沿值(descent)；对于其他，它代表了最高的重音符号的下沿值(descent)；最 后，其他格式把它定义为跟global_bbox.yMin相同。这个字段的值是负数。&nbsp;<br><br>text_height&nbsp;<br>这个字段是在使用这个字体书写文本时用来计算默认的行距的（例如，基线到基线之间的距离）。注意，通常它都比ascender和descent的绝对值之和还要大。另外，不保证使用这个距离后面就没有字形高于或低于基线。&nbsp;<br><br>max_advance_width&nbsp;<br>这个字段指出了字体中所有字形得最大的水平光标推进宽度。它可以用来快速计算字符串得最大推进宽度。它不等于最大字形图像宽度！&nbsp;<br><br>max_advance_height&nbsp;<br>跟max_advance_width一样，但是用在垂直文本排版。它只在字体提供垂直字形度量时才可用。&nbsp;<br><br>underline_position&nbsp;<br>当显示或者渲染下划线文本时，这个值等于下划线到基线的垂直距离。当下划线低于基线时这个值为负数。&nbsp;<br><br>underline_thickness&nbsp;<br>当显示或者渲染下划线文本时，这个值等于下划线的垂直宽度。&nbsp;<br><br>现在注意，很不幸的，由于字体格式多种多样，ascender和descender的值是不可靠的。&nbsp;<br><br><strong>b.伸缩的全局度量</strong>&nbsp;<br><br>每一个size对象同时包含了上面描述的某些全局度量的伸缩版本。它们可以通过face-&gt;size-&gt;metrics结构直接访问。&nbsp;<br><br>注意这些值等于预设全局变量的伸缩版本，但没有做舍入或网格对齐。它们也完全独立于任何hinting处理。换句话说，不要依靠它们来获取象素级别的精确度量。它们以26.6象素格式表示。&nbsp;<br><br>ascender&nbsp;<br>原始预设ascender的伸缩版本。&nbsp;<br><br>descender&nbsp;<br>原始预设ascender的伸缩版本。&nbsp;<br><br>height&nbsp;<br>原始预设文本高度(text_height)的伸缩版本。这可能是这个结构中你真正会用到的字段。&nbsp;<br><br>max_advance&nbsp;<br>原始预设最大推进的伸缩版本。&nbsp;<br><br>注意，face-&gt;size-&gt;metrics结构还包含其他字段，用来伸缩预设坐标到设备空间。它们会在最后一章描述。&nbsp;<br><br><strong>c.字距调整</strong>&nbsp;<br><br>字距调整是调整字符串中两个并排的字形图像位置的过程，它可以改善文本的整体外观。基本上，这意味着当‘A’的跟着‘V’时，它们之间的间距可以稍微减少，以此避免额外的“对角线空白”。&nbsp;<br><br>注意，理论上字距调整适用于水平和垂直方向的两个字形，但是，除了非常极端的情况外，几乎在所有情况下，它只会发生在水平方向。&nbsp;<br><br>不是所有的字体格式包含字距调整信息。有时候它们依赖于一个附加的文件来保存不同的字形度量，包括字距调整，但该文件不包含字形图像。一个显著的 例子就是Type1格式。它的字形图像保存在一个扩展名为.pfa或.pfb的文件中，字距调整度量存放在一个附加的扩展名为.afm或.pfm的文件 中。&nbsp;<br><br>FreeType 2提供了FT_Attach_File和FT_Attach_Stream API来让你处理这种情况。两个函数都是用来装载附加的度量到一个face对象中，它通过从附加的特定格式文件中读取字距调整度量来实现。例如，你可以象 下面那样打开一个Type1字体：&nbsp;<br><br>error = FT_New_Face( library, "/usr/shared/fonts/cour.pfb",&nbsp;<br>0, &amp;face );&nbsp;<br>if ( error ) { ... }&nbsp;<br><br>error = FT_Attach_File( face, "/usr/shared/fonts/cour.afm" );&nbsp;<br>if ( error )&nbsp;<br>{ ... 没能读取字距调整和附加的度量 ... }&nbsp;<br><br>注意，FT_Attach_Stream跟FT_Attach_File是类似的，不同的是它不是以C字符串指定附加文件，而是以一个FT_Stream句柄。另外，读取一个度量文件不是强制性的。&nbsp;<br><br>最后，文件附加API是非常通用的，可以用来从指定的face中装载不同类型的附加信息。附加内容的种类完全是因字体格式而异的。&nbsp;<br><br>FreeType 2允许你通过FT_Get_Kerning函数获取两个字形的字距调整信息，该函数界面如下：&nbsp;<br><br>FT_Vector kerning;&nbsp;<br><br>...&nbsp;<br>error = FT_Get_Kerning( face, /* face对象的句柄 */&nbsp;<br>left, /* 左边字形索引 */&nbsp;<br>right, /* 右边字形索引 */&nbsp;<br>kerning_mode, /* 字距调整模式 */&nbsp;<br>&amp;kerning ); /* 目标矢量 */&nbsp;<br><br>正如你所见到的，这个函数的参数有一个face对象的句柄、字距调整值所要求的左边和右边字形索引，以及一个称为字距调整模式的整数，和目标矢量的指针。目标矢量返回适合的距离值。&nbsp;<br><br>字距调整模式跟前一章描述的bbox模式(bbox mode)是很类似的。这是一个枚举值，指示了目标矢量如何表示字距调整距离。&nbsp;<br><br>默认值是FT_KERNING_DEFAULT，其数值为0。它指示字距调整距离以26.6网格对齐象素（这意味着该值是64的倍数）的形式表示。对于可伸缩格式，这意味着返回值是把预设字距调整距离先伸缩，然后舍入。&nbsp;<br><br>值FT_KERNING_UNFITTED指示了字距调整距离以26.6非对齐象素（也就是，那不符合整数坐标）的形式表示。返回值是把预设字距调整伸缩，但不舍入。&nbsp;<br><br>最后，值FT_KERNING_UNSCALED是用来返回预设字距调整距离，它以字体单位的格式表示。你可以在稍后用本部分的最后一章描述的算式把它拉伸到设备空间。&nbsp;<br><br>注意，“左”和“右”位置是指字符串字形的可视顺序。这对双向或由右到左的文本来说是很重要的。&nbsp;<br><br><strong>4.简单的文本渲染：字距调整+居中</strong>&nbsp;<br><br>为了显示我们刚刚学到的知识，现在我们将示范如何修改第一部分给出的代码以渲染一个字符串，并且增强它，使它支持字距调整和延迟渲染。&nbsp;<br><br><strong>a.字距调整支持</strong>&nbsp;<br><br>要是我们只考虑处理从左到右的文字，如拉丁文，那在我们的代码上添加字距调整是很容易办到的。我们只要获取两个字形之间的字距调整距离，然后适当地改变笔位置。代码如下：&nbsp;<br><br>FT_GlyphSlot slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br>FT_UInt glyph_index;&nbsp;<br>FT_Bool use_kerning;&nbsp;<br>FT_UInt previous;&nbsp;<br>int pen_x, pen_y, n;&nbsp;<br><br>... 初始化库 ...&nbsp;<br>... 创建face对象 ...&nbsp;<br>... 设置字符尺寸 ...&nbsp;<br><br>pen_x = 300;&nbsp;<br>pen_y = 200;&nbsp;<br><br>use_kerning = FT_HAS_KERNING( face );&nbsp;<br>previous = 0;&nbsp;<br><br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>/* 把字符码转换为字形索引 */&nbsp;<br>glyph_index = FT_Get_Char_Index( face, text[n] );&nbsp;<br><br>/* 获取字距调整距离，并且移动笔位置 */&nbsp;<br>if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )&nbsp;<br>{&nbsp;<br>FT_Vector delta;&nbsp;<br><br>FT_Get_Kerning( face, previous, glyph_index,&nbsp;<br>ft_kerning_mode_default, &amp;delta );&nbsp;<br><br>pen_x += delta.x &gt;&gt; 6;&nbsp;<br>}&nbsp;<br><br>/* 装载字形图像到字形槽（擦除之前的字形图像） */&nbsp;<br>Error = FT_Load_Glyph(face, glyph_index, FT_LOAD_RENDER);&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误 */&nbsp;<br><br>/* 现在绘制到我们的目标表面(surface) */&nbsp;<br>my_draw_bitmap( &amp;slot-&gt;bitmap,&nbsp;<br>pen_x + slot-&gt;bitmap_left,&nbsp;<br>pen_y - slot-&gt;bitmap_top );&nbsp;<br><br>/* 增加笔位置 */&nbsp;<br>pen_x += slot-&gt;advance.x &gt;&gt; 6;&nbsp;<br><br>/* 记录当前字形索引 */&nbsp;<br>previous = glyph_index;&nbsp;<br>}&nbsp;<br><br>若干注解：&nbsp;<br><br>* 因为字距调整是由字形索引决定的，我们需要显式转换我们的字符代码到字形索引，然后调用FT_Load_Glyph而不是FT_Load_Char。&nbsp;<br><br>* 我们使用一个名为use_kerning的变量，它的值为宏FT_HAS_KERNING的结果。当我们知道字体face不含有字距调整信息，不调用FT_Get_kerning程序将执行得更快。&nbsp;<br><br>* 我们在绘制一个新字形前移动笔位置。&nbsp;<br><br>* 我们以值0初始化变量previous，这表示“字形缺失(missing glyph)”（在Postscript中，这用.notdef表示）。该字形也没有字距调整距离。&nbsp;<br><br>* 我们不检查FT_Get_kerning返回得错误码。这是因为这个函数在错误发生时总是把delta置为(0,0)。&nbsp;<br><br><strong>b.居中</strong>&nbsp;<br><br>我们的代码开始变得有趣了，但对普通应用来说仍然有点太简单了。例如，笔的位置在我们渲染前就决定了。通常，你要在计算文本的最终位置（居中，等）前布局它和测量它，或者执行自动换行。&nbsp;<br><br>现在让我们把文字渲染函数分解为两个截然不同但连续的两部分：第一部分将在基线上定位每一个字形图像，第二部分将渲染字形。我们将看到，这有很多好处。&nbsp;<br><br>我们先保存每一个独立的字形图像，以及它们在基线上面的位置。这可以通过如下的代码完成：&nbsp;<br><br>FT_GlyphSlot slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br>FT_UInt glyph_index;&nbsp;<br>FT_Bool use_kerning;&nbsp;<br>FT_UInt previous;&nbsp;<br>int pen_x, pen_y, n;&nbsp;<br><br>FT_Glyph glyphs[MAX_GLYPHS]; /* 字形图像 */&nbsp;<br>FT_Vector pos [MAX_GLYPHS]; /* 字形位置 */&nbsp;<br>FT_UInt num_glyphs;&nbsp;<br><br>... 初始化库 ...&nbsp;<br>... 创建face对象 ...&nbsp;<br>... 设置字符尺寸 ...&nbsp;<br><br>pen_x = 0; /* 以 (0,0) 开始 */&nbsp;<br>pen_y = 0;&nbsp;<br><br>num_glyphs = 0;&nbsp;<br>use_kerning = FT_HAS_KERNING( face );&nbsp;<br>previous = 0;&nbsp;<br><br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>/* 把字符码转换为字形索引 */&nbsp;<br>glyph_index = FT_Get_Char_Index( face, text[n] );&nbsp;<br><br>/* 获取字距调整距离，并且移动笔位置 */&nbsp;<br>if ( use_kerning &amp;&amp; previous &amp;&amp; glyph_index )&nbsp;<br>{&nbsp;<br>FT_Vector delta;&nbsp;<br><br>FT_Get_Kerning( face, previous, glyph_index,&nbsp;<br>FT_KERNING_DEFAULT, &amp;delta );&nbsp;<br><br>pen_x += delta.x &gt;&gt; 6;&nbsp;<br>}&nbsp;<br><br>/* 保存当前笔位置 */&nbsp;<br>pos[num_glyphs].x = pen_x;&nbsp;<br>pos[num_glyphs].y = pen_y;&nbsp;<br><br>/* 装载字形图像到字形槽，不渲染它 */&nbsp;<br>error=FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT);&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误，跳到下一个字形 */&nbsp;<br><br>/* 提取字形图像并把它保存在我们的表中 */&nbsp;<br>error = FT_Get_Glyph( face-&gt;glyph, &amp;glyphs[num_glyphs] );&nbsp;<br>if ( error )&nbsp;<br>continue; /* 忽略错误，跳到下一个字形 */&nbsp;<br><br>/* 增加笔位置 */&nbsp;<br>pen_x += slot-&gt;advance.x &gt;&gt; 6;&nbsp;<br><br>/* 记录当前字形索引 */&nbsp;<br>previous = glyph_index;&nbsp;<br><br>/* 增加字形数量 */&nbsp;<br>num_glyphs++;&nbsp;<br>}&nbsp;<br><br>相对于我们之前的代码，这有轻微的变化：我们从字形槽中提取每一个字形图像，保存每一个字形图像和它对应的位置在我们的表中。&nbsp;<br><br>注意pen_x包含字符串的整体前移值。现在我们可以用一个很简单的函数计算字符串的边界框(bounding box)，如下：&nbsp;<br><br>void compute_string_bbox( FT_BBox *abbox )&nbsp;<br>{&nbsp;<br>FT_BBox bbox;&nbsp;<br><br>/* 初始化字符串bbox为“空”值 */&nbsp;<br>bbox.xMin = bbox.yMin = 32000;&nbsp;<br>bbox.xMax = bbox.yMax = -32000;&nbsp;<br><br>/* 对于每一个字形图像，计算它的边界框，平移它，并且增加字符串bbox */&nbsp;<br>for ( n = 0; n &lt; num_glyphs; n++ )&nbsp;<br>{&nbsp;<br>FT_BBox glyph_bbox;&nbsp;<br><br>FT_Glyph_Get_CBox( glyphs[n], ft_glyph_bbox_pixels,&nbsp;<br>&amp;glyph_bbox );&nbsp;<br><br>glyph_bbox.xMin += pos[n].x;&nbsp;<br>glyph_bbox.xMax += pos[n].x;&nbsp;<br>glyph_bbox.yMin += pos[n].y;&nbsp;<br>glyph_bbox.yMax += pos[n].y;&nbsp;<br><br>if ( glyph_bbox.xMin &lt; bbox.xMin )&nbsp;<br>bbox.xMin = glyph_bbox.xMin;&nbsp;<br><br>if ( glyph_bbox.yMin &lt; bbox.yMin )&nbsp;<br>bbox.yMin = glyph_bbox.yMin;&nbsp;<br><br>if ( glyph_bbox.xMax &gt; bbox.xMax )&nbsp;<br>bbox.xMax = glyph_bbox.xMax;&nbsp;<br><br>if ( glyph_bbox.yMax &gt; bbox.yMax )&nbsp;<br>bbox.yMax = glyph_bbox.yMax;&nbsp;<br>}&nbsp;<br><br>/* 检查我们是否真的增加了字符串bbox */&nbsp;<br>if ( bbox.xMin &gt; bbox.xMax )&nbsp;<br>{&nbsp;<br>bbox.xMin = 0;&nbsp;<br>bbox.yMin = 0;&nbsp;<br>bbox.xMax = 0;&nbsp;<br>bbox.yMax = 0;&nbsp;<br>}&nbsp;<br><br>/* 返回字符串bbox */&nbsp;<br>*abbox = bbox;&nbsp;<br>}&nbsp;<br><br>最终得到的边界框尺寸以整数象素的格式表示，并且可以随后在渲染字符串前用来计算最终的笔位置，如下：&nbsp;<br><br>/* 计算整数象素表示的字符串尺度 */&nbsp;<br>string_width = string_bbox.xMax - string_bbox.xMin;&nbsp;<br>string_height = string_bbox.yMax - string_bbox.yMin;&nbsp;<br><br>/* 计算以26.6笛卡儿象素表示的笔起始位置*/&nbsp;<br>start_x = ( ( my_target_width - string_width ) / 2 ) * 64;&nbsp;<br>start_y = ( ( my_target_height - string_height ) / 2 ) * 64;&nbsp;<br><br>for ( n = 0; n &lt; num_glyphs; n++ )&nbsp;<br>{&nbsp;<br>FT_Glyph image;&nbsp;<br>FT_Vector pen;&nbsp;<br><br>image = glyphs[n];&nbsp;<br><br>pen.x = start_x + pos[n].x;&nbsp;<br>pen.y = start_y + pos[n].y;&nbsp;<br><br>error = FT_Glyph_To_Bitmap(&amp;image, FT_RENDER_MODE_NORMAL,&nbsp;<br>&amp;pen, 0 );&nbsp;<br>if ( !error )&nbsp;<br>{&nbsp;<br>FT_BitmapGlyph bit = (FT_BitmapGlyph)image;&nbsp;<br><br>my_draw_bitmap( bit-&gt;bitmap,&nbsp;<br>bit-&gt;left,&nbsp;<br>my_target_height - bit-&gt;top );&nbsp;<br><br>FT_Done_Glyph( image );&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>一些说明：&nbsp;<br><br>* 笔位置以笛卡儿空间（例如，y向上）的形式表示。&nbsp;<br><br>* 我们调用FT_Glyph_To_Bitmap时destroy参数设置为0(false)，这是为了避免破坏原始字形图像。在执行该调用后，新的字形位图通过image访问，并且它的类型转变为FT_BitmapGlyph。&nbsp;<br><br>* 当调用FT_Glyph_To_Bitmap时，我们使用了平移。这可以确保位图字形对象的左区域和上区域已经被设置为笛卡儿空间中的正确的象素坐标。&nbsp;<br><br>* 当然，在渲染前我们仍然需要把象素坐标从笛卡儿空间转换到设备空间。因此在调用my_draw_bitmap前要先计算my_target_height – bitmap-&gt;top。&nbsp;<br><br>相同的循环可以用来把字符串渲染到我们的显示面(surface)任意位置，而不需要每一次都重新装载我们的字形图像。我们也可以决定实现自动换行或者只是绘制。&nbsp;<br><br><strong>5.高级文本渲染：变换 + 居中 + 字距调整</strong>&nbsp;<br><br>现在我们将修改我们的代码，以便可以容易地变换已渲染的字符串，例如旋转它。我们将以实行少许小改进开始：&nbsp;<br><br><strong>a.打包然后平移字形</strong>&nbsp;<br><br>我们先把与一个字形图像相关的信息打包到一个结构体，而不是并行的数组。因此我们定义下面的结构体类型：&nbsp;<br><br>typedef struct TGlyph_&nbsp;<br>{&nbsp;<br>FT_UInt index; /* 字形索引 */&nbsp;<br>FT_Vector pos; /* 基线上面的字形原点 */&nbsp;<br>FT_Glyph image; /* 字形图像 */&nbsp;<br>} TGlyph, *PGlyph;&nbsp;<br><br>我们在装载每一个字形图像过程中，在把它装载它在基线所在位置后便直接平移它。我们将看到，这有若干好处。我们的字形序列装载其因而变成：&nbsp;<br><br>FT_GlyphSlot slot = face-&gt;glyph; /* 一个小捷径 */&nbsp;<br>FT_UInt glyph_index;&nbsp;<br>FT_Bool use_kerning;&nbsp;<br>FT_UInt previous;&nbsp;<br>int pen_x, pen_y, n;&nbsp;<br><br>TGlyph glyphs[MAX_GLYPHS]; /* 字形表 */&nbsp;<br>PGlyph glyph; /* 表中的当前字形*/&nbsp;<br>FT_UInt num_glyphs;&nbsp;<br><br>... 初始化库 ...&nbsp;<br>... 创建face对象 ...&nbsp;<br>... 设置字符尺寸 ...&nbsp;<br><br>pen_x = 0; /* 以 (0,0) 开始 */&nbsp;<br>pen_y = 0;&nbsp;<br><br>num_glyphs = 0;&nbsp;<br>use_kerning = FT_HAS_KERNING( face );&nbsp;<br>previous = 0;&nbsp;<br><br>glyph = glyphs;&nbsp;<br>for ( n = 0; n &lt; num_chars; n++ )&nbsp;<br>{&nbsp;<br>glyph-&gt;index = FT_Get_Char_Index( face, text[n] );&nbsp;<br><br>if ( use_kerning &amp;&amp; previous &amp;&amp; glyph-&gt;index )&nbsp;<br>{&nbsp;<br>FT_Vector delta;&nbsp;<br><br>FT_Get_Kerning( face, previous, glyph-&gt;index,&nbsp;<br>FT_KERNING_MODE_DEFAULT, &amp;delta );&nbsp;<br><br>pen_x += delta.x &gt;&gt; 6;&nbsp;<br>}&nbsp;<br><br>/* 保存当前笔位置 */&nbsp;<br>glyph-&gt;pos.x = pen_x;&nbsp;<br>glyph-&gt;pos.y = pen_y;&nbsp;<br><br>error = FT_Load_Glyph(face,glyph_index,FT_LOAD_DEFAULT);&nbsp;<br>if ( error ) continue;&nbsp;<br><br>error = FT_Get_Glyph( face-&gt;glyph, &amp;glyph-&gt;image );&nbsp;<br>if ( error ) continue;&nbsp;<br><br>/* 现在平移字形图像 */&nbsp;<br>FT_Glyph_Transform( glyph-&gt;image, 0, &amp;glyph-&gt;pos );&nbsp;<br><br>pen_x += slot-&gt;advance.x &gt;&gt; 6;&nbsp;<br>previous = glyph-&gt;index;&nbsp;<br><br>/* 增加字形的数量 */&nbsp;<br>glyph++;&nbsp;<br>}&nbsp;<br><br>/* 计算已装载的字形的数量 */&nbsp;<br>num_glyphs = glyph - glyphs;&nbsp;<br><br>注意，这个时候平移字形有若干好处。第一是当我们计算字符串的边界框时不需要平移字形bbox。代码将会变成这样：&nbsp;<br><br>void compute_string_bbox( FT_BBox *abbox )&nbsp;<br>{&nbsp;<br>FT_BBox bbox;&nbsp;<br><br>bbox.xMin = bbox.yMin = 32000;&nbsp;<br>bbox.xMax = bbox.yMax = -32000;&nbsp;<br><br>for ( n = 0; n &lt; num_glyphs; n++ )&nbsp;<br>{&nbsp;<br>FT_BBox glyph_bbox;&nbsp;<br><br>FT_Glyph_Get_CBox( glyphs[n], &amp;glyph_bbox );&nbsp;<br><br>if (glyph_bbox.xMin &lt; bbox.xMin)&nbsp;<br>bbox.xMin = glyph_bbox.xMin;&nbsp;<br><br>if (glyph_bbox.yMin &lt; bbox.yMin)&nbsp;<br>bbox.yMin = glyph_bbox.yMin;&nbsp;<br><br>if (glyph_bbox.xMax &gt; bbox.xMax)&nbsp;<br>bbox.xMax = glyph_bbox.xMax;&nbsp;<br><br>if (glyph_bbox.yMax &gt; bbox.yMax)&nbsp;<br>bbox.yMax = glyph_bbox.yMax;&nbsp;<br>}&nbsp;<br><br>if ( bbox.xMin &gt; bbox.xMax )&nbsp;<br>{&nbsp;<br>bbox.xMin = 0;&nbsp;<br>bbox.yMin = 0;&nbsp;<br>bbox.xMax = 0;&nbsp;<br>bbox.yMax = 0;&nbsp;<br>}&nbsp;<br><br>*abbox = bbox;&nbsp;<br>}&nbsp;<br><br>更详细描述：compute_string_bbox函数现在可以计算一个已转换的字形字符串的边界框。例如，我们可以做如下的事情：&nbsp;<br><br>FT_BBox bbox;&nbsp;<br>FT_Matrix matrix;&nbsp;<br>FT_Vector delta;&nbsp;<br><br>... 装载字形序列 ...&nbsp;<br>... 设置 "matrix" 和 "delta" ...&nbsp;<br><br>/* 变换字形 */&nbsp;<br>for ( n = 0; n &lt; num_glyphs; n++ )&nbsp;<br>FT_Glyph_Transform( glyphs[n].image, &amp;matrix, &amp;delta );&nbsp;<br><br>/* 计算已变换字形的边界框 */&nbsp;<br>compute_string_bbox( &amp;bbox );&nbsp;<br><br><strong>b.渲染一个已变换的字形序列</strong>&nbsp;<br><br>无论如何，如果我们想重用字形来以不同的角度或变换方式绘制字符串，直接变换序列中的字形都不是一个好主意。更好的方法是在字形被渲染前执行放射变换，如下面的代码所示：&nbsp;<br><br>FT_Vector start;&nbsp;<br>FT_Matrix transform;&nbsp;<br><br>/* 获取原始字形序列的 bbox */&nbsp;<br>compute_string_bbox( &amp;string_bbox );&nbsp;<br><br>/* 计算整数象素表示的字符串尺度 */&nbsp;<br>string_width = (string_bbox.xMax - string_bbox.xMin) / 64;&nbsp;<br>string_height = (string_bbox.yMax - string_bbox.yMin) / 64;&nbsp;<br><br>/* 设置26.6笛卡儿空间表示的笔起始位置 */&nbsp;<br>start.x = ( ( my_target_width - string_width ) / 2 ) * 64;&nbsp;<br>start.y = ( ( my_target_height - string_height ) / 2 ) * 64;&nbsp;<br><br>/* 设置变换（旋转） */&nbsp;<br>matrix.xx = (FT_Fixed)( cos( angle ) * 0x10000L );&nbsp;<br>matrix.xy = (FT_Fixed)(-sin( angle ) * 0x10000L );&nbsp;<br>matrix.yx = (FT_Fixed)( sin( angle ) * 0x10000L );&nbsp;<br>matrix.yy = (FT_Fixed)( cos( angle ) * 0x10000L );&nbsp;<br><br>for ( n = 0; n &lt; num_glyphs; n++ )&nbsp;<br>{&nbsp;<br>FT_Glyph image;&nbsp;<br>FT_Vector pen;&nbsp;<br>FT_BBox bbox;&nbsp;<br><br>/* 创建原始字形的副本 */&nbsp;<br>error = FT_Glyph_Copy( glyphs[n].image, &amp;image );&nbsp;<br>if ( error ) continue;&nbsp;<br><br>/* 变换副本（这将平移它到正确的位置） */&nbsp;<br>FT_Glyph_Transform( image, &amp;matrix, &amp;start );&nbsp;<br><br>/* 检查边界框；如果已变换的字形图像不在*/&nbsp;<br>/* 我们的目标表面中，我们可以避免渲染它 */&nbsp;<br>FT_Glyph_Get_CBox( image, ft_glyph_bbox_pixels, &amp;bbox );&nbsp;<br>if ( bbox.xMax &lt;= 0 || bbox.xMin &gt;= my_target_width ||&nbsp;<br>bbox.yMax &lt;= 0 || bbox.yMin &gt;= my_target_height )&nbsp;<br>continue;&nbsp;<br><br>/* 把字形图像转换为位图（销毁字形的副本！） */&nbsp;<br>error = FT_Glyph_To_Bitmap(&nbsp;<br>&amp;image,&nbsp;<br>FT_RENDER_MODE_NORMAL,&nbsp;<br>0, /* 没有附加的平移*/&nbsp;<br>1 ); /* 销毁 "image" 指向的副本 */&nbsp;<br>if ( !error )&nbsp;<br>{&nbsp;<br>FT_BitmapGlyph bit = (FT_BitmapGlyph)image;&nbsp;<br><br>my_draw_bitmap( bitmap-&gt;bitmap,&nbsp;<br>bitmap-&gt;left,&nbsp;<br>my_target_height - bitmap-&gt;top );&nbsp;<br>FT_Done_Glyph( image );&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>这份代码相对于原始版本有少许改变：&nbsp;<br><br>* 我们没改变原始的字形图像，而是变换该字形图像的拷贝。&nbsp;<br><br>* 我们执行“剪取”操作以处理渲染和绘制的字形不在我们的目标表面(surface)的情况。&nbsp;<br><br>* 当调用FT_Glyhp_To_Bitmap时，我们总是销毁字形图像的拷贝，这是为了销毁已变换的图像。注意，即使当这个函数返回错误码，该图像依然会被销毁（这就是为什么FT_Done_Glyph只在复合语句中被调用的原因）。&nbsp;<br><br>* 平移字形序列到起始笔位置集成到FT_Glyph_Transform函数，而不是FT_Glyph_To_Bitmap函数。&nbsp;<br><br>可以多次调用这个函数以渲染字符串到不同角度的，或者甚至改变计算start的方法以移动它到另外的地方。&nbsp;<br><br>这份代码是FreeType 2示范程序ftstring.c的基础。它可以被简单地扩展，在第一部发完成高级文本布局或自动换行，而第二部分不需改变。&nbsp;<br><br>无论如何，要注意通常的实现会使用一个字形缓冲以减少内存消耗。据个例子，让我们假定我们的字符串是“FreeType”。我们将在我们的表中保存字母‘e’的三个相同的字形图像，这不是最佳的（特别是当你遇到更长的字符串或整个页面时）。&nbsp;<br><br><strong>6.以预设字体单位的格式访问度量，并且伸缩它们</strong>&nbsp;<br><br>可伸缩的字体格式通常会为字体face中的每一个字形保存一份矢量图像，该矢量图像称为轮廓。每一个轮廓都定义在一个抽象的网格中，该网格被称为 预设空间(design space)，其坐标以名义上(nominal)的字体单位(font unit)表示。当装载一个字形图像时，字体驱动器通常会依照FT_Size对象所指定的当前字符象素尺寸把轮廓伸缩到设备空间。字体驱动器也能修改伸缩 过的轮廓以大大地改善它在基于象素的表面(surface)中显示的效果。修改动作通常称为hinting或网格对齐。&nbsp;<br><br>这一章描述了如何把预设坐标伸缩到设备空间，以及如何读取字形轮廓和如何获取以预设字体单位格式表示的度量。这对许多事情来说都是重要的：&nbsp;<br><br>* 真正的所见即所得文字排版&nbsp;<br><br>* 为了字体转换或者分析的目的而访问字体内容&nbsp;<br><br><strong>a.伸缩距离到设备空间</strong>&nbsp;<br><br>我们使用一个简单的伸缩变换把预设坐标伸缩到设备空间。变换系数借助字符象素尺寸来计算：&nbsp;<br><br>Device_x = design_x * x_scale&nbsp;<br>Device_y = design_y * y_scale&nbsp;<br><br>X_scale = pixel_size_x / EM_size&nbsp;<br>Y_scale = pixel_size_y / EM_size&nbsp;<br><br>这里，值EM_Size是因字体而异的，并且对应预设空间的一个抽象矩形（称为EM）的大小。字体设计者使用该矩形创建字形图像。EM_Size 以字体单元的形式表示。对于可伸缩字体格式，可以通过face-&gt;unix_per_EM直接访问。你应该使用FT_IS_SCALABLE宏检查 某个字体face是否包含可伸缩字形图像，当包含时该宏返回true。&nbsp;<br><br>当你调用函数FT_Set_Pixel_Sizes，你便指定了pixel_size_x和pixel_size_y的值。FreeType库将会立即使用该值计算x_scale和y_scale的值。&nbsp;<br><br>当你调用函数FT_Set_Char_Size，你便以物理点的形式指定了字符尺寸。FreeType库将会使用该值和设备的解析度来计算字符象素尺寸和相应的比例因子。&nbsp;<br><br>注意，在调用上面提及的两个函数后，你可以通过访问face-&gt;size-&gt;metrices结构的字段得到字符象素尺寸和比例因子的值。这些字段是：&nbsp;<br><br>X_ppem&nbsp;<br>这个字段代表了“每一个EM的x方向象素”，这是以整数象素表示EM矩形的水平尺寸，也是字符水平象素尺寸，即上面例子所称的pixel_size_x。&nbsp;<br><br>y_ppem&nbsp;<br>这个字段代表了“每一个EM的y方向象素”，这是以整数象素表示EM矩形的垂直尺寸，也是字符垂直象素尺寸，即上面例子所称的pixel_size_y。&nbsp;<br><br>X_scale&nbsp;<br>这是一个16.16固定浮点比例，用来把水平距离从预设空间直接伸缩到1/64设备象素。&nbsp;<br><br>y_scale&nbsp;<br>这是一个16.16固定浮点比例，用来把垂直距离从预设空间直接伸缩到1/64设备象素。&nbsp;<br><br>你可以借助FT_MulFix函数直接伸缩一个以26.6象素格式表示的距离，如下所示：&nbsp;<br><br>/* 把预设距离转换到1/64象素 */&nbsp;<br>pixels_x=FT_MulFix(design_x,face-&gt;size-&gt;metrics.x_scale);&nbsp;<br>pixels_y=FT_MulFix(design_y,face-&gt;size-&gt;metrics.y_scale);&nbsp;<br><br>当然，你也可以使用双精度浮点数更精确地伸缩该值：&nbsp;<br><br>FT_Size_Metrics* metrics = &amp;face-&gt;size-&gt;metrics; /* 捷径 */&nbsp;<br>double pixels_x, pixels_y;&nbsp;<br>double em_size, x_scale, y_scale;&nbsp;<br><br>/* 计算浮点比例因子 */&nbsp;<br>em_size = 1.0 * face-&gt;units_per_EM;&nbsp;<br>x_scale = metrics-&gt;x_ppem / em_size;&nbsp;<br>y_scale = metrics-&gt;y_ppem / em_size;&nbsp;<br><br>/* 把预设距离转换为浮点象素 */&nbsp;<br>pixels_x = design_x * x_scale;&nbsp;<br>pixels_y = design_y * y_scale;&nbsp;<br><br><strong>b.访问预设度量（字形的和全局的）</strong>&nbsp;<br><br>你可以以字体单位的格式访问字形度量，只要在调用FT_Load_Glyph或FT_Load_Char时简单地指定FT_LOAD_NO_SCALE位标志便可以了。度量返回在face-&gt;glyph_metrics，并且全部都以字体单位的格式表示。&nbsp;<br><br>你可以使用FT_KERNING_MODE_UNSCALED模式访问未伸缩的字距调整数据。&nbsp;<br><br>最后，FT_Face句柄的字段包含少数几个全局度量，我们已经在本部分的第三章叙述过了。&nbsp;<br><br><strong>结论</strong>&nbsp;<br><br>这是FreeType 2教程第二部分的结尾。现在你可以访问字形度量，管理字形图像，以及更巧妙地渲染文字（字距调整，测量，变换和缓冲）。&nbsp;<br><br>现在你有了足够的知识能够以FreeType2为基础构建一个相当好的文字服务，而且要是你愿意，你可以在这里止步了。&nbsp;<br><br>下一部分将涉及FreeType2的内部（例如模块，矢量轮廓，设备驱动器，渲染器），以及少数的字体格式特有的问题（主要是，如何访问某些TrueType或Type 1表）。【这部分还没有编写】</span></td>
</tr>
</tbody>
</table>
<p></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info">
<div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(2562529,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
        <a id="green_channel_follow" onclick="follow(&#39;fcf5a971-92be-e111-aa3f-842b2b196315&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./FreeType2中文手册_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./FreeType2中文手册_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
        <div id="author_profile_detail" class="author_profile_info">
            <a href="https://home.cnblogs.com/u/htc-javaMe/">htc开发</a><br>
            <a href="https://home.cnblogs.com/u/htc-javaMe/followees/">关注 - 0</a><br>
            <a href="https://home.cnblogs.com/u/htc-javaMe/followers/">粉丝 - 19</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;fcf5a971-92be-e111-aa3f-842b2b196315&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(2562529,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">1</span>
    </div>
    <div class="buryit" onclick="votePost(2562529,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>

<script type="text/javascript">
    currentDiggType = 0;
</script></div>
    <div class="clear"></div>
    <div id="post_next_prev">

    <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/11/13/2562530.html" class="p_n_p_prefix">« </a> 上一篇：    <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/11/13/2562530.html" title="发布于 2010-11-13 17:32">《c++ prime》读书笔记－－模板与泛型编程</a>
    <br>
    <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/14/2562528.html" class="p_n_p_prefix">» </a> 下一篇：    <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/14/2562528.html" title="发布于 2010-12-14 21:23">Linux下openGL开发</a>

</div>
</div>
        <div class="clear"></div>
        <div id="blog_post_info_block">
        <div id="blog_post_info">
        </div>
        <div class="clear"></div>
        <div id="post_next_prev"></div>
    </div>
</div>
    <ul class="postmetadata">
        
<li class="icon_cat" id="BlogPostCategory">
分类            <a href="https://www.cnblogs.com/htc-javaMe/category/390667.html" target="_blank">嵌入式</a>
</li>
<li class="icon_bullet" id="EntryTag">
&nbsp;</li>
    </ul>
</div>
<script type="text/javascript">
    var m = window.__blog.postRendered;
    if (m) { m(__$("post")); }
</script>
<script type="text/javascript">
    var m = window.__blog.postRenderPosts;
    if (m) { m(); }
</script>
<script src="./FreeType2中文手册_files/highlight.min.js.下载"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 120909, cb_blogApp = 'htc-javaMe', cb_blogUserGuid = 'fcf5a971-92be-e111-aa3f-842b2b196315';
    var cb_entryId = 2562529, cb_entryCreatedDate = '2010-12-12 22:18', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder">

<div id="comment_pager_top">
    
</div>

<a class="addcomment" href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html#comment_tip">Add your comment</a>
<h3 id="comments"></h3><div class="feedbackNoItems"></div>
<script language="javascript" type="text/javascript">
    var m = window.__blog.preRenderCommentList;
    if (m) { m(); }
</script>

<ol class="commentlist" id="commentList">	
		<li class="alt">
			<h5>
				<cite>
<a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html#4527497" class="layer">#1楼</a>
<a name="4527497" id="comment_anchor_4527497"></a>

        <span id="comment-maxId" style="display:none">4527497</span>
        <span id="comment-maxDate" style="display:none">2020/3/20 下午4:26:42</span>
</cite> 

            <a id="a_comment_author_4527497" href="https://home.cnblogs.com/u/1978715/" target="_blank">皮皮马爱佳麒</a>
<small>
<span class="comment_date">2020-03-20 16:26</span>

</small>
			</h5>
			
<div id="comment_body_4527497" data-format-type="Markdown" class="blog_comment_body cnblogs-markdown">
    <p>大佬，文章可以转走吗？</p>

</div>
        <div class="comment_vote">
            <span class="comment_error" style="color: red"></span>
            <a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(4527497, &#39;Digg&#39;, this.parentElement, false);">
                支持(0)
            </a>
            <a href="javascript:void(0);" class="comment_burry" onclick="return voteComment(4527497, &#39;Bury&#39;, this.parentElement, false);">
                反对(0)
            </a>
        </div>
        

			<div class="opt_comment">

<span class="comment_actions">
    
    
    
    
</span>

</div>
		</li>
</ol>

<script language="javascript" type="text/javascript">
    var m = window.__blog.commentListRendered;
    if (m) { m(__$("commentList")); }
</script>

<div id="comment_pager_bottom">
    
</div>


</div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html#" onclick="return RefreshPage();">刷新页面</a><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html#top">返回顶部</a></div>
    <div id="comment_form_container" style="visibility: visible;"><div class="login_tips">
    注册用户登录后才能发表评论，请 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a>
     或 
    <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，
    <a href="https://www.cnblogs.com/">访问</a> 网站首页。
</div></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"><a href="https://www.wenjuan.com/s/3uIjeq0/" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-博客园问卷调查&#39;)">【推荐】了解你才能更懂你，博客园首发问卷调查，助力社区新升级</a><br><a href="http://www.ucancode.com/index.htm" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-ucancode&#39;)">【推荐】超50万行VC++源码: 大型组态工控、电力仿真CAD与GIS源码库</a><br><a href="https://developer.aliyun.com/article/744670?utm_content=g_1000104140" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-阿里云开发者社区&#39;)">【推荐】如何在面试中成长？来看阿里前端终面官的面试心得</a><br><a href="https://developer.aliyun.com/ask/257928?utm_content=g_1000088948" target="_blank" onclick="ga(&#39;send&#39;, &#39;event&#39;, &#39;Link&#39;, &#39;click&#39;, &#39;T2-阿里云开发者社区&#39;)">【推荐】精品问答：精品问答：Python 技术 1000 问</a><br></div>
    <div id="opt_under_post"></div>
    <script async="async" src="./FreeType2中文手册_files/gpt.js.下载"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block" style="">
        <div id="div-gpt-ad-1546353474406-0" style="height: 250px; width: 300px;"><div id="google_ads_iframe_/1090369/C1_0__container__" style="border: 0pt none; width: 300px; height: 250px;"></div></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block" style="">
        <div id="div-gpt-ad-1539008685004-0" style="height: 60px; width: 468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        <div id="google_ads_iframe_/1090369/C2_0__container__" style="border: 0pt none; width: 468px; height: 60px;"></div></div>
    </div>
    <div id="under_post_kb">
<div class="itnews c_ad_block">
    <b>最新 IT 新闻</b>:
    <br>
 ·              <a href="https://news.cnblogs.com/n/662296/" target="_blank">入局直播，财报亮眼，百度迎来“新春天”</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/662295/" target="_blank">张朝阳：搜狐已回到安全地带 Q2将进入稳定盈利状态</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/662294/" target="_blank">微博Q1营收3.2亿美元 净利5210万美元同比降65%</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/662293/" target="_blank">研究：石墨烯能让碳纤维变得更硬更坚固且更便宜</a>
            <br>
 ·              <a href="https://news.cnblogs.com/n/662292/" target="_blank">《愤怒的小鸟》开发商谈远程办公：严重影响生产力</a>
            <br>
    » <a href="https://news.cnblogs.com/" title="IT 新闻" target="_blank">更多新闻...</a>
</div></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


        </div>

        <script type="text/javascript">
            var m = window.__blog.contentRendered;
            if (m) { m(__$("content")); }
        </script>

        <div id="sidebar">
            <div id="about">
                <div>
                    <h2 id="about_title">About</h2>
                    <div id="about_body">
                        <div id="sidebar_news">

<div id="blog-news">
    <script type="text/javascript">window['__document_write_ajax_callbacks__']['8']();</script><script type="text/javascript">window['__document_write_ajax_callbacks__']['1']();</script>
<div style="display: none" id="__document_write_ajax_div-2"></div><script type="text/javascript">window['__document_write_ajax_callbacks__']['2']();</script>
<script type="text/javascript">window['__document_write_ajax_callbacks__']['9']();</script><script type="text/javascript">window['__document_write_ajax_callbacks__']['3']();</script>
<div style="display: none" id="__document_write_ajax_div-4"></div><script type="text/javascript">window['__document_write_ajax_callbacks__']['4']();</script>
<script type="text/javascript">window['__document_write_ajax_callbacks__']['10']();</script><script type="text/javascript">window['__document_write_ajax_callbacks__']['5']();</script>
<div style="display: none" id="__document_write_ajax_div-6"></div><script type="text/javascript">window['__document_write_ajax_callbacks__']['6']();</script>
    <div id="profile_block">
        昵称：
        <a href="https://home.cnblogs.com/u/htc-javaMe/">
            htc开发
        </a>
        <br>
        园龄：
        <a href="https://home.cnblogs.com/u/htc-javaMe/" title="入园时间：2012-06-25">
            7年10个月
        </a>
        <br>
        粉丝：
        <a href="https://home.cnblogs.com/u/htc-javaMe/followers/">
            19
        </a>
        <br>
        关注：
        <a href="https://home.cnblogs.com/u/htc-javaMe/followees/">
            0
        </a>
        <div id="p_b_follow">
<a href="javascript:void(0)" onclick="follow(&#39;fcf5a971-92be-e111-aa3f-842b2b196315&#39;)">+加关注</a></div>
        <script type="text/javascript">window['__document_write_ajax_callbacks__']['11']();</script><script>window['__document_write_ajax_callbacks__']['7']();</script>
    </div>
</div>

</div>
                        <script type="text/javascript">loadBlogNews();</script>
                    </div>
                </div>
            </div>
            <script type="text/javascript">
                var m = window.__blog.aboutRendered;
                if (m) { m(__$("about")); }
            </script>
            <div id="mySearchWrapper">
                <div id="mySearch">
                    <input type="image" src="./FreeType2中文手册_files/btnsearch.gif" id="btnZzk" class="submit" onclick="zzk_go();return false;">
                    <label class="lb_search"><input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="keyword"></label>
                </div>
            </div>
            <script type="text/javascript">
                var m = window.__blog.searchFormRendered;
                if (m) { m(__$("searchform")); }
            </script>
            <div id="sideMain">
            <div id="side-recent-comments">
    

<h2>最新评论</h2>
<ul class="voice">
        <li>
            <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html">Re:FreeType2中文手册</a>
            <br>
            <a class="child" href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html">
                <p>大佬，文章可以转走吗？</p>

                -- 皮皮马爱佳麒
            </a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/htc-javaMe/archive/2009/12/29/2562547.html">Re:集群</a>
            <br>
            <a class="child" href="https://www.cnblogs.com/htc-javaMe/archive/2009/12/29/2562547.html">
                很不错
                -- 岁月漫步
            </a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/03/25/2562438.html">Re:javascript 俄罗斯方块 游戏</a>
            <br>
            <a class="child" href="https://www.cnblogs.com/htc-javaMe/archive/2012/03/25/2562438.html">
                楼主大哥  有米有完整版的
                -- 山经の风
            </a>
        </li>
        <li>
            <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/05/08/2562240.html">Re:开源搜索引擎</a>
            <br>
            <a class="child" href="https://www.cnblogs.com/htc-javaMe/archive/2012/05/08/2562240.html">
                最近搞了个网页版的集成搜索 , 九合.com 可以交流一下。
                -- 浮山狼
            </a>
        </li>
</ul>

</div></div>
            <div id="sideRight">
            <div id="side-archives">
            <h2>随笔档案</h2>
            <ul class="date">
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/06.html">2012年6月(37)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/05.html">2012年5月(24)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/04.html">2012年4月(20)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/03.html">2012年3月(31)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/02.html">2012年2月(33)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2012/01.html">2012年1月(10)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/12.html">2011年12月(38)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/11.html">2011年11月(18)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/10.html">2011年10月(6)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/09.html">2011年9月(15)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/08.html">2011年8月(16)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/07.html">2011年7月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/06.html">2011年6月(19)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/05.html">2011年5月(10)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/04.html">2011年4月(7)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/03.html">2011年3月(5)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2011/02.html">2011年2月(5)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12.html">2010年12月(5)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/11.html">2010年11月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/09.html">2010年9月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/08.html">2010年8月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/06.html">2010年6月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/05.html">2010年5月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/04.html">2010年4月(5)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/03.html">2010年3月(5)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/02.html">2010年2月(7)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2010/01.html">2010年1月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/12.html">2009年12月(8)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/11.html">2009年11月(16)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/10.html">2009年10月(20)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/09.html">2009年9月(12)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/08.html">2009年8月(7)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/07.html">2009年7月(10)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/06.html">2009年6月(10)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/05.html">2009年5月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/04.html">2009年4月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2009/02.html">2009年2月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/12.html">2008年12月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/11.html">2008年11月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/09.html">2008年9月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/08.html">2008年8月(7)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/07.html">2008年7月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/06.html">2008年6月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/05.html">2008年5月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/04.html">2008年4月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/03.html">2008年3月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/02.html">2008年2月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2008/01.html">2008年1月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/12.html">2007年12月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/10.html">2007年10月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/09.html">2007年9月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/08.html">2007年8月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/07.html">2007年7月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/06.html">2007年6月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/05.html">2007年5月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/03.html">2007年3月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/02.html">2007年2月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2007/01.html">2007年1月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/12.html">2006年12月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/11.html">2006年11月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/10.html">2006年10月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/09.html">2006年9月(7)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/06.html">2006年6月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/05.html">2006年5月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/02.html">2006年2月(6)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2006/01.html">2006年1月(8)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/12.html">2005年12月(4)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/09.html">2005年9月(1)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/08.html">2005年8月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/07.html">2005年7月(6)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/06.html">2005年6月(3)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/05.html">2005年5月(2)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/04.html">2005年4月(4)</a></li>
                    <li><a href="https://www.cnblogs.com/htc-javaMe/archive/2005/01.html">2005年1月(11)</a></li>
            </ul>
        </div>








        

        





    


    

<div id="topdigg_posts_wrap">
<div id="side-top-posts-custom">
        <h2>推荐排行榜</h2>
        <div id="TopDiggPostsBlock">
            <ul style="word-break:break-all">
                        <li>
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/01/03/2562546.html">
                                1. 垂头丧气的时候，看这些文字吧(2)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/06/01/2562232.html">
                                2. listView添加上下文菜单问题(1)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/02/27/2562443.html">
                                3. Linux安装程序Anaconda分析(1)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2011/05/25/2562513.html">
                                4. C++中Static作用和使用方法(1)
                            </a>
                        </li>
                        <li>
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html">
                                5. FreeType2中文手册(1)
                            </a>
                        </li>
            </ul>
        </div>
    </div>
</div></div>
            <div id="sideLeft">
            <div id="side-calendar">
    <h2>日历</h2>
    <div id="blog-calendar">

<table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar" border="0">
    <tbody>
        <tr>
            <td colspan="7">
                <table class="CalTitle" cellspacing="0" border="0">
                    <tbody>
                        <tr>
                            <td class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2010/11/12&#39;); return false;">&lt;</a>
                            </td>
                            <td align="center">2010年12月</td>
                            <td align="right" class="CalNextPrev">
                                <a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2011/01/12&#39;); return false;">&gt;</a>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </td>
        </tr>
        <tr>
                    <th class="CalDayHeader" align="center" abbr="日" scope="col">日</th>
                    <th class="CalDayHeader" align="center" abbr="一" scope="col">一</th>
                    <th class="CalDayHeader" align="center" abbr="二" scope="col">二</th>
                    <th class="CalDayHeader" align="center" abbr="三" scope="col">三</th>
                    <th class="CalDayHeader" align="center" abbr="四" scope="col">四</th>
                    <th class="CalDayHeader" align="center" abbr="五" scope="col">五</th>
                    <th class="CalDayHeader" align="center" abbr="六" scope="col">六</th>
        </tr>
            <tr>
                            <td class="CalOtherMonthDay" align="center">28</td>
                            <td class="CalOtherMonthDay" align="center">29</td>
                            <td class="CalOtherMonthDay" align="center">30</td>
                        <td class="" align="center">
                            1
                        </td>
                        <td class="" align="center">
                            2
                        </td>
                        <td class="" align="center">
                            3
                        </td>
                    <td class="CalWeekendDay" align="center">
                        4
                    </td>
            </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            5
                        </td>
                            <td class="" align="center">
                                6
                            </td>
                            <td class="" align="center">
                                7
                            </td>
                            <td class="" align="center">
                                8
                            </td>
                            <td class="" align="center">
                                9
                            </td>
                            <td class="" align="center">
                                10
                            </td>
                        <td class="CalWeekendDay" align="center">
                            11
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12.html"><u>12</u></a>
                        </td>
                            <td class="" align="center">
                                13
                            </td>
                            <td class="" align="center">
                                <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/14.html"><u>14</u></a>
                            </td>
                            <td class="" align="center">
                                <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/15.html"><u>15</u></a>
                            </td>
                            <td class="" align="center">
                                16
                            </td>
                            <td class="" align="center">
                                17
                            </td>
                        <td class="CalWeekendDay" align="center">
                            18
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/19.html"><u>19</u></a>
                        </td>
                            <td class="" align="center">
                                20
                            </td>
                            <td class="" align="center">
                                21
                            </td>
                            <td class="" align="center">
                                22
                            </td>
                            <td class="" align="center">
                                23
                            </td>
                            <td class="" align="center">
                                24
                            </td>
                        <td class="CalWeekendDay" align="center">
                            25
                        </td>
                </tr>
                <tr>
                        <td class="CalWeekendDay" align="center">
                            26
                        </td>
                            <td class="" align="center">
                                27
                            </td>
                            <td class="" align="center">
                                28
                            </td>
                            <td class="" align="center">
                                29
                            </td>
                            <td class="" align="center">
                                30
                            </td>
                            <td class="" align="center">
                                31
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            1
                        </td>
                </tr>
                <tr>
                        <td class="CalOtherMonthDay" align="center">
                            2
                        </td>
                            <td class="CalOtherMonthDay" align="center">
                                3
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                4
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                5
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                6
                            </td>
                            <td class="CalOtherMonthDay" align="center">
                                7
                            </td>
                        <td class="CalOtherMonthDay" align="center">
                            8
                        </td>
                </tr>
    </tbody>
</table></div>
    <script>loadBlogDefaultCalendar();</script>
</div><div id="side-hottags">
    
</div><div id="side-categories">
            <h2>随笔分类</h2>
            <ul class="folder">
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390631.html">.Net(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390653.html">Android开发(32)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390655.html">Android学习(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390630.html">Apache(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390657.html">ARM相关(20)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390616.html">C(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390676.html">C/C++大海捞针(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390674.html">C++(13)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390675.html">C++设计模式(7)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390618.html">CSS(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390633.html">Database(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390658.html">DSP相关(6)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390659.html">EDA相关(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390626.html">GAE(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390660.html">GUI(7)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390694.html">Hadoop(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390661.html">HomeR2专题(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390619.html">HTML(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390704.html">IOS开发经验技巧(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390702.html">IOS开发入门(13)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390652.html">iphone开发(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390627.html">Java(8)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390624.html">jQuery(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390625.html">JS(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390677.html">LAMP(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390707.html">Lbs研究(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390622.html">Linux(11)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390678.html">Linux程序设计（C／C++）(13)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390679.html">linux设备驱动程序(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390698.html">linux系统分析(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390662.html">linux相关(19)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390629.html">MySQL(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390634.html">NoSql(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390628.html">PHP(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390708.html">Php开发(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390637.html">Python(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390641.html">Qt(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390680.html">RHCE认证材料学习笔记(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390639.html">Shell(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390681.html">Shell脚本(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390706.html">Symbian开发(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390617.html">Unix(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390700.html">vim设置(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390623.html">Web(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390699.html">web应用(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390621.html">Win32(10)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390620.html">Windows(9)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390663.html">Windows开发(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390670.html">编程相关(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390686.html">操作系统(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390665.html">传真通信(6)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390669.html">独眼看天下(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390685.html">感想(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390636.html">公开课(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390668.html">机器人及人工智能(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390692.html">计算机英语(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390697.html">脚本语言(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390689.html">精华转帖(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390656.html">面试笔试(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390709.html">其他(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390667.html">嵌入式(9)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390664.html">人生经历(14)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390671.html">软件(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390672.html">软件工程及项目管理(20)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390703.html">深入浅出Objective-C(4)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390687.html">数据库(5)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390638.html">算法(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390688.html">算法设计与分析(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390682.html">体会(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390673.html">通信相关(15)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390683.html">图像&amp;amp;图形(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390693.html">图像&amp;图形(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390666.html">图像图形处理(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390691.html">网络(6)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390651.html">文字类(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390690.html">系统管理(13)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390684.html">心得(2)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390701.html">信息安全(1)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390642.html">业余项目(9)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390640.html">游戏(8)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390695.html">云计算和虚拟化(3)</a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/category/390696.html">运维人员必备—Linux工作手记(7)</a>
                    </li>
            </ul>
        </div><div id="side-top-posts">
    <h2>阅读排行榜</h2>
    <div id="TopViewPostsBlock">
        <ul style="word-break:break-all">
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/06/19/2562227.html">
                            1. 实现半透明popupWindow(11406)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/archive/2009/12/26/2562548.html">
                            2. 基于ARM的嵌入式linux 内核的裁剪与移植(4428)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/02/27/2562443.html">
                            3. Linux安装程序Anaconda分析(4181)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/archive/2010/12/12/2562529.html">
                            4. FreeType2中文手册(2955)
                        </a>
                    </li>
                    <li>
                        <a href="https://www.cnblogs.com/htc-javaMe/archive/2012/05/20/2562124.html">
                            5. 用Qt开发简单的浏览器（一）(2845)
                        </a>
                    </li>
        </ul>
    </div>
</div></div>            
                <div id="sideContainer"></div>
                <script type="text/javascript">
                    $.ajax({
                        url: '/' + currentBlogApp + '/ajax/Minyx2_Lite_SideColumn.aspx',
                        data: '{}',
                        type: 'post',
                        dataType: 'text',
                        contentType: 'application/json; charset=utf-8',
                        success: function (data) {
                            if (data) {
                                $("#sideContainer").html(data);
                                $.ajax({
                                    url: getAjaxBaseUrl() + 'TopLists.aspx',
                                    type: 'get',
                                    dataType: 'text',
                                    success: function (topLists) {
                                        if (topLists) {
                                            $("#sideContainer").append(topLists);
                                        }
                                        var m = window.__blog.sideContainerRendered;
                                        if (m) { m(__$("sideContainer")); }
                                        window.__blog.sidebar.__layout();
                                    }
                                });
                            }
                        }
                    });

                </script>
        </div>

        <script type="text/javascript">
            var m = window.__blog.sidebarRendered;
            if (m) { m(__$("sidebar")); }
        </script>

        <div id="footer">
            <p id="logoFoot">
    <a href="http://www.spiga.com.mx/" title="Agencia Interactiva Spiga">www.spiga.com.mx</a>
</p>
<div class="footText">
<p>
Copyright © 2020 htc开发
<br><span id="poweredby">Powered by .NET Core on Kubernetes</span>

</p>
<p>
<a href="http://www.cnblogs.com/">博客园</a>
</p>
</div>


        </div>
    </div>

    <script type="text/javascript">
        var m = window.__blog.wrapperRendered;
        if (m) { m(__$("wrapper")); }
    </script>

</div>
<script type="text/javascript">
    var m = window.__blog.containerRendered;
    if (m) { m(__$("container")); }
</script>


    <div id="page_end_html">
        <script type="text/javascript">
alimama_pid="mm_10002723_2390296_9317862";
alimama_width=950;
alimama_height=90;
</script>
<script src="./FreeType2中文手册_files/inf.js.下载" type="text/javascript"></script>
    </div>

<script type="text/javascript">
alimama_pid="mm_10002723_2390296_9334223";
alimama_width=950;
alimama_height=90;
</script><script type="text/javascript">
alimama_pid="mm_10002723_2390296_9777841";
alimama_width=120;
alimama_height=240;
</script><script type="text/javascript">
alimama_pid="mm_10002723_2390296_9317281";
alimama_width=120;
alimama_height=240;
</script><script type="text/javascript">
alimama_pid="mm_10002723_2390296_9216101";
alimama_width=120;
alimama_height=240;
</script><script type="text/javascript">getFollowStatus('fcf5a971-92be-e111-aa3f-842b2b196315');</script></body></html>