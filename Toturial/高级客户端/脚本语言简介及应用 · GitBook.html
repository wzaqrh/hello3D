<!DOCTYPE html>
<!-- saved from url=(0055)https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html -->
<html lang=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        
        
        <title>脚本语言简介及应用 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="./脚本语言简介及应用 · GitBook_files/style.css">

    
            
                
                <link rel="stylesheet" href="./脚本语言简介及应用 · GitBook_files/website.css">
                
            
                
                <link rel="stylesheet" href="./脚本语言简介及应用 · GitBook_files/search.css">
                
            
                
                <link rel="stylesheet" href="./脚本语言简介及应用 · GitBook_files/website(1).css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://gitbook.corp.sdo.com/seniorlcient/book/gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="https://gitbook.corp.sdo.com/seniorlcient/book/gitbook/images/favicon.ico" type="image/x-icon">

    
    
    
    

    <style></style><link rel="prev" href="https://gitbook.corp.sdo.com/seniorlcient/book/User_Interface/fairy_gui.html"><link rel="next" href="https://gitbook.corp.sdo.com/seniorlcient/book/Architecture.html"></head>
    <body>
        
<div class="book without-animation with-summary font-size-2 font-family-1">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search">
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/">
            
                    
                    目录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="RenderPipeline.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/RenderPipeline.html">
            
                    
                    渲染 - 熟悉前向渲染、延迟渲染管线流程
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="LightingModel.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/LightingModel.html">
            
                    
                    渲染 - 熟悉各种光照模型原理及实现（PBR、次表面散射、各向异性等）
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="PostProcess.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/PostProcess.html">
            
                    
                    渲染 - 熟悉各种后处理效果实现方法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="GI.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/GI.html">
            
                    
                    渲染 - 了解全局光照
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="GeometryInstancing.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/GeometryInstancing.html">
            
                    
                    优化 - Geometry Instancing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="Profiling.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Profiling.html#gpu%E4%BC%98%E5%8C%96">
            
                    
                    优化 - GPU优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="Profiling.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Profiling.html#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96">
            
                    
                    优化 - 其他优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="Algorithm.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Algorithm.html">
            
                    
                    算法 - 基础算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="TerrainRendering.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/TerrainRendering.html">
            
                    
                    地形 - 地形绘制
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="PathFinding.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/PathFinding.html">
            
                    
                    寻路 - 导航网格寻路
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="QuadtreeAndOctreeSceneManagent.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/QuadtreeAndOctreeSceneManagent.html">
            
                    
                    场景管理 - 四叉树、八叉树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="3D_Animation.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/3D_Animation.html">
            
                    
                    动画 - 骨骼动画及其优化
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="Grass_Animation.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Grass_Animation.html">
            
                    
                    动画 - UV 动画、顶点动画的原理与应用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="Asset_Bundle.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Asset_Bundle.html">
            
                    
                    资源管理 - AssetBundle 的使用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="User_Interface/PlugIn.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/User_Interface/PlugIn.html">
            
                    
                    UI - 常用插件概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="User_Interface/MainstreamTechnology.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/User_Interface/MainstreamTechnology.html">
            
                    
                    UI - 主流技术概述
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="User_Interface/fairy_gui.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/User_Interface/fairy_gui.html">
            
                    
                    UI - FairlyGUI简介
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.19" data-path="Lua.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html">
            
                    
                    脚本语言简介及应用
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="Architecture.html">
            
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Architecture.html">
            
                    
                    架构设计模式
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com/" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <a class="btn pull-left js-toolbar-action" aria-label="" href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html#"><i class="fa fa-align-justify"></i></a><div class="dropdown pull-right js-toolbar-action"><a class="btn toggle-dropdown" aria-label="Share" href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html#"><i class="fa fa-share-alt"></i></a><div class="dropdown-menu dropdown-left"><div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div><div class="buttons"><button class="button size-5 ">Facebook</button><button class="button size-5 ">Google+</button><button class="button size-5 ">Twitter</button><button class="button size-5 ">Weibo</button><button class="button size-5 ">Instapaper</button></div></div></div><a class="btn pull-right js-toolbar-action" aria-label="" href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html#"><i class="fa fa-facebook"></i></a><a class="btn pull-right js-toolbar-action" aria-label="" href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html#"><i class="fa fa-twitter"></i></a><div class="dropdown pull-left font-settings js-toolbar-action"><a class="btn toggle-dropdown" aria-label="Font Settings" href="https://gitbook.corp.sdo.com/seniorlcient/book/Lua.html#"><i class="fa fa-font"></i></a><div class="dropdown-menu dropdown-right"><div class="dropdown-caret"><span class="caret-outer"></span><span class="caret-inner"></span></div><div class="buttons"><button class="button size-2 font-reduce">A</button><button class="button size-2 font-enlarge">A</button></div><div class="buttons"><button class="button size-2 ">Serif</button><button class="button size-2 ">Sans</button></div><div class="buttons"><button class="button size-3 ">White</button><button class="button size-3 ">Sepia</button><button class="button size-3 ">Night</button></div></div></div><h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="https://gitbook.corp.sdo.com/seniorlcient/">脚本语言简介及应用</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="脚本语言基础及应用"><strong>脚本语言基础及应用</strong></h1>
<h2 id="序">序</h2>
<p>​    本章将着力介绍在游戏开发中所涉及的脚本应用及相关语言知识. </p>
<p>分别从语言基础, 游戏应用意义及引擎插件汇等多方面阐述. 希望通过本章学习, 能掌握相关脚本语言开发技能并融入游戏研发的实践之中.</p>
<h2 id="lua语言基础">Lua语言基础</h2>
<p>​    Lua作为最典型的脚本语言. 其最大的优势在于运行时效率. </p>
<p>​    所谓脚本语言的定义这里存在一个普片的误区. 很多人认为脚本语言的定义为不需要编译的语言为脚本语言, 其实不然. 类似于Lua其实也同样需要编译, 并且也支持预编译. 预编译后的文件在链接（解释）时. 效率要高于源文件.  而相对准确的脚本语言定义为： "能相对快速并轻易的加载并运行动态代码的语言". </p>
<h3 id="chunk">Chunk</h3>
<p>​    接下来我们来介绍Lua中第一个概念. Chunk. 在Lua解释器运行时. 程式时通过逐代码块进行解释. 通常用Do-End结构限定代码块结构. 而对于没有没有使用类似Do-End（结构限定符）所修饰的代码片段而言. 解释器将进行逐行解释. </p>
<p>​    很多同学可能会产生疑问， Chunk的作用有哪些? 接下来我将简单列举一些显而易见的作用:</p>
<p>​    a) 联系上下文. 限定词法界限;</p>
<p>​        又是一个新名词, 词法界限. 所谓词法界限举个通俗易懂的例子就是函数内的局部变量. 局部变量的生命周期为函数的生命周期. Do-End结构就类似于此. 在代码段中限定局部变量的生命周期. </p>
<p>​    b) Lua中存在一个为交互模式的驱动状态. 其中一种表现形式就类似使用控制台进行输入输出的驱动调试. 而前面也说，Lua代码的解释是以行或代码块驱动的.  如果仅以行输入，可能会存在输入不完全就进行解释的情况. 导致交互存在偏差.</p>
<p>​    c) 预编译块, 预编译与编译类似需要进行块状编译. </p>
<p>​    d) 解释速度提升. 类似网络加载一样. 下载内容绝大多数时远不及网络连接开销. 通过代码块能有效的合并冗余的代码片段. 从而提升解释器运行时效率.</p>
<h3 id="全局变量与局部变量">全局变量与局部变量</h3>
<p>​    Lua中默认的变量为全局变量. </p>
<p>​    其实从原理上来说，Lua语言并不不存在全局变量. 所谓的全局变量的实现方式是同过"Env(环境)与G表"来实现. 简单的来说. Lua源文件做为一个个脚本， 一个脚本就是一个命名域. 不同域名之间的全局变量共享的方式是通过把全局变量加载到G表之中. 而在每一个脚本加载前, 会先加载G表数据. 从而实现全局变量共享. </p>
<p>​    另外一种形式为环境模式中的上值. 可以把他想想为外部的局部变量. 这里请记住这个上值, 因为在Lua的核心设计模式中, 上值这概念始终伴随左右. 每一次程序加载并编译时首先会加载对应脚本文件, 其次加载环境全局变量表. 我们可以在程式中动态覆盖环境变量表. 已达成在不同环境下全局变量共享差异. 在进行这类操作时, 要注意代码的词法限定, 以免发生运行时异常的情况.</p>
<p>​    而对于局部变量, 是Lua中提倡的书写方式. 在变量前增加local 修饰符加以修饰. 此处需要注意的是local 存在自身的词法界限. 特别是动态代码加载时, 通过字符串生成的代码是不接受词法界限限制. 在这种特殊情况下, 经常容易出现运行时异常. 当然, 动态代码生成所涉及场景比较少, 因为同样的样式完全可使用更高效的书写方式代替.</p>
<h3 id="表">表</h3>
<p>​    表是一种动态分配的对象， 程序只能操作指向表的引用. Lua程序不会创建新的表或者拷贝隐藏的表;</p>
<p>​     表也可以实现其他语言的各类数据结构以及做为面向对象编程中的结构体及类的表现形式;</p>
<p>​    对于一个表而言, 当程序中不在有指向它的引用时, 垃圾收集器会最终删除这个表，并重用其占得内存.</p>
<p>​    如全局变量一样，未经初始化的表为nil, 表原色可以将其删除. (如上所述，Lua其实就是用表实现全局变量的G表) </p>
<p>​    当表的索引能够被转化为整型的浮点数会被自动转化;</p>
<p>​    表能够被嵌套，并且表的索引从1起始; 标的长度通常用n表示; 所有元素不为空的表称为序列; 对于存在空洞的表，他的长度是不可靠的. 如果使用泛型遍历表, 所返回索引节点是随机的. </p>
<p>​    表存在标准库,其包含Insert, Remove等接口</p>
<p>​    在面向对象编程中, 可以理解为表为对象的类. 表内容为对象的属性. 而方法视同表名+冒号+函数名实现. 其中冒号为省略了Self, 否则则需要在参数中传入对应对象. </p>
<p>​    为了实现面向对象中的继承, 引入了元表概念. 及表A为表B的原表, 那么表B继承表A；</p>
<h3 id="函数">函数</h3>
<p>​    Lua函数返回值可以返回多个参数, 由于Lua存在堆栈上限, 返回值最大个数上限默认1百万个, 不能超过1MB.</p>
<p>​    当函数被圆括号包含，仅去第一个返回结果. 例: (fun()).</p>
<p>​    当参数为... 时, 以为者传参为可变长参数.  具有可变长参数的函数意味着函数可以具有任意数量的参数. 但固定参数必须放在可变长参数之前.</p>
<p>​    Lua语言提供了table.pack. 该函数表达式{...} 一样保存所有参数. 然后将其放在一个表中返回. 但这个表还保存了一个返回参数个数的字段n. 另一个具有可变长参数的函数是Select. Select函数具有一个固定参数selector, 以及数量可变的参数. 如果select的数值是N, 那么返回第N个参数后的值. 默认为#, 为返回全部参数.</p>
<p>​    Lua的另一个特性为尾调用.  在尾调用之后， 程序也就不需要再调用栈中保存有关函数的信息.  这中实现称为尾调用消除.</p>
<h3 id="闭包">闭包</h3>
<p>​    Lua语言中, 函数严格遵守词法定界,的第一类值. 第一类值以为着Lua语言中函数与其他类型的值具有同等权限.</p>
<p>​    当编写一个被其他函数B包含的函数A时, 被包含的函数A可以访问包含其的函数B的所有局部变量. 我们将这种特性称为词法定界.</p>
<p>​    Lua语言中非局部变量由于历史原因也被称为上值. </p>
<p>​    一个闭包就是一个函数外加能够使该函数访问非局部变量所需的其他机制. 从机制上来说, Lua语言只有闭包, 没有函数, 函数本身是闭包的一种.</p>
<h3 id="模块和包">模块和包</h3>
<p>​    本小节主要讲述Require的条用条件. Require 在Lua5.1版本前是使用loader监听器，在之后版本改为Searcher. 当程序在对下一块Chunk进行检测时, 如果对应内容为Require， 则先判断堆栈内是否存在相关内容, 存在直接返回堆栈数据, 反之触发相关的Loader或Searcher. 如果监听不能返回相关加载对象. 则触发Lua中默认环境路径. 程序中设定为Packager.path. 如果还获取不到, 则触发CLua Path 中相关加载环境. 不能获取文件内容则返回异常. </p>
<p>​    而Dostring与Dofile调用的文件对象则都是要重复加载并编译后推入堆栈. 所以推荐使用Require. 这也是为什么XLua中只写一个Main， 其余文件都通过Main中Require进行引用的原因.</p>
<h3 id="预编译">预编译</h3>
<p>​    脚本语言与非脚本语言额区别并非在于编译与否, 二是在于能否快速且轻易的编译生成动态脚本. </p>
<p>​    Lua语言同样支持预编译后进行加载. 编译后的文件为二进制. 且格式为 预编译标识符+ 版本号+格式+转换判断吗 + 二进制预编译内容. 通常会更大一些.</p>
<p>​    但预编译的好处显而易见, 原先的加载-&gt;解密-&gt;编译-&gt;推入堆栈 改变为 加载-&gt; 推入堆栈. 经典的空间换时间. 但要注意的是. 32位于64位由于并非运行时编译, 所以需要提前确认运行环境. 可以通过判断INT的位数来确认.</p>
<h3 id="瞬表及垃圾回收">瞬表及垃圾回收</h3>
<p>​    Lua中的表的K-V为了防止相互引用出现的锁死. 所以推出了弱引用, 并且发展未了瞬表. 具体原理不在这里阐述, 有兴趣的同学可以去查阅相关资料. 这里值得提一下的是，Lua采取的垃圾回收机制未一代算法, 通过ROOT跟来判断是否未激活状态, 但由于之前所说的尾消除特性. 当A仅被B引用， 且B未被引用时.  我们强制回收会激活A, 然后回收B. 所以需要再次强制回收. 才能彻底回收成功. 这也是Lua独特的特性之一.</p>
<h2 id="xlua-应用">XLua 应用</h2>
<p>​    在长期的脚本插件迭代中XLua以一定的优势脱颖而出. 也成为了目前最主流的Lua解决方案. 但其实它并没有对Lua进行多大的修改. 反而抛弃了一些通用接口. 但其在平台层的策略及一些类的辅助工具还是使他存在了很大的优势.</p>
<p>​     相对学习Lua, 光光使用XLua的上手度更为简单. 但还是推荐先了解相关Lua知识. 再来使用XLua, 这样就能明白他的设计目的及利弊.</p>
<h3 id="简单使用步骤">简单使用步骤:</h3>
<p>​    首先通过建立LuaEnv初始化Lua信息, 表结构及回调函数监听. 然后通过Dostring来加载初始化Main.lua文件. 之后的书写规范都已Lua 为准.</p>
<h3 id="调用顺序及步骤">调用顺序及步骤:</h3>
<p>​    Lua的解析分为两种, 一为二进制的预编译文件，二位文本内容.  首先去除BOM 及Linux下的#头.</p>
<p><img src="file:///D:/Projects/Git/seniorclient/book/Lua/1.png" alt="1"></p>
<p>​    之后判断是否为预编译文件. 如果部位预编译, 则进行编译, 堆栈推入. 如果是预编译, 则需要进行一下步骤</p>
<p><img src="file:///D:/Projects/Git/seniorclient/book/Lua/2.jpg" alt="2"></p>
<p>之后又回到相同条用关系. 进行Chunk级解析并推入堆栈. 其中值得注意的是, 在这环节调用了ll_Require(), 此函数的逻辑未之前叙述的Require的行为.</p>
<h3 id="ccalllua及luacallc处理">C#CallLua及LuaCallC#处理</h3>
<p>​    目的仅为规避反射而提前生成代码段. 使LUA与C#在相同环境下. 提升运行失效率. 如果没有生成对应代码段. 则在调用时会认为为位置类型, 并且LUA也不是强语言, 所以只能 通过反射类获取目标函数接口. 当然，也有列外. 可以通过LUA提供的T cast(table, T)的API用于强转，把该table转成一个T指明的类型，可以是一个加了CSharpCallLua声明的interface，一个有默认构造函数的class或者struct，一个Dictionary，List等等.</p>
<p>​    一下连接有相关转换数据的具体内容及原理.</p>
<p>​    <a href="https://blog.csdn.net/wangjiangrong/article/details/79916646" target="_blank">https://blog.csdn.net/wangjiangrong/article/details/79916646</a></p>
<h3 id="xlua转化及使用规则">XLua转化及使用规则</h3>
<p>LuaCallCSharp
备注：Lua Call C#代码的时候，C#处生成的代码基本都需要打标签[LuaCallCSharp]。关于标签的理解，将在后面的文章详细讲解。</p>
<ol>
<li>new 一个C#对象
我们在C#中生成一个对象，比如GameObject，代码如下：</li>
</ol>
<p>GameObject go = new GameObject();
那么Lua是怎么写的呢？如下：</p>
<p>local go = CS.UnityEngine.GameObject()
知识点：首先在Lua中没有new关键字，所以新建对象的时候直接省略new即可，其次所有C#相关的都要加上前缀"CS."包括构造函数，静态成员属性、方法。同时别忘了加上命名空间namespace。所以C#的GameObject类，在Lua中就是CS.UnityEngine.GameObject。</p>
<p>当class有多个构造函数时，xlua中也支持重载，如GameObject有一个带一个string参数的重载用于给该GameObject命名，对应的Lua实现如下：</p>
<p>local go = CS.UnityEngine.GameObject('helloworld')
2.访问C#静态属性、方法
由上面我们可以知道Lua中调用GameObject的类为CS.UnityEngine.GameObject，那么如果想调用GameObject中的静态方法，比如Find(string)，如下：</p>
<p>local go = CS.UnityEngine.GameObject.Find('helloworld')
访问静态属性也是同理，比如：</p>
<p>CS.UnityEngine.Time.deltaTime</p>
<p>--赋值
CS.UnityEngine.Time.timeScale = 0.5
建议：需要经常访问的类，可以先用局部变量引用后访问，即可以减少代码量，还可以提高性能，如：</p>
<p>local GameObject = CS.UnityEngine.GameObject</p>
<p>--使用的时候
GameObject.Find('helloworld')
GameObject.FindGameObjectsWithTag("tag")
3.访问C#成员属性、方法
与C#一样，访问成员属性方法的时候，需要通过类的实例去访问。</p>
<p>假设我们在C#中定义了如下类：</p>
<p>namespace MyExamples {
    [LuaCallCSharp]
    public class Test {
        public int index;
        public int Add(int a, int b) {
            return a + b;
        }
    }
}
那么对应的Lua即：</p>
<p>local Test = CS.MyExamples.Test;
local test = Test();
test.index = 66;
print('test.index---'..test.index);
print('test.Add---'..test.Add(test,1,2));
print('test:Add---'..test:Add(3,4));
需要注意的是：若用 . 调用成员方法，第一个参数需要传递该对象，所以建议使用 : 访问（冒号语法糖）</p>
<p>4.访问父类属性、方法
XLua支持（通过派生类）访问基类的静态属性，静态方法，（通过派生类的实例）访问基类的成员属性，成员方法。</p>
<p>5.参数的输入输出属性（out，ref）
参数处理规则：Lua调用C#方法的时候，C#方法中的参数，从左到右，普通参数算一个输入形参，ref修饰的算一个输入形参，out修饰的不算。</p>
<p>返回值处理规则：Lua接受C#方法返回值的时候，C#方法的返回值（如果有）算一个返回值，（形参中的）ref算一个返回值，out算一个返回值，从左到右对应lua的多返回值。</p>
<p>具体什么意思？直接上代码。如下，我们在C#中有一个方法：</p>
<p>namespace MyExamples {
    [LuaCallCSharp]
    public class A {
        public static int Method(int a, ref int b, out int c, Action funA, out Action funB) {
            Debug.Log("Method-----a:" + a + "----b:" + b);
            c = 10;
            funA();
            funB = () =&gt; { Debug.Log("exe---funB"); };
            return 5;
        }
    }
}
按照上面的规则，我们可以用下面的Lua来处理：</p>
<p>--每个返回值都对应返回值的规则
--每个输入的实参都对应参数的规则
local ret, ret_b, ret_c, ret_funB = CS.MyExamples.A.Method(1,2,function()
    print('exe----funA');
end);
print('CS.MyExamples.A.Method  return---', ret, ret_b, ret_c, ret_funB);
ret_funB();
注意：这里我们将lua中的function传递到了C#中的Action参数中，等于上一篇说讲到的lua函数映射到c#委托，因此我们需要将Action添加到CSharpCallLua的白名单中，关于标签白名单，后续文章会讲解。类似的还有Func&lt;&gt;等委托（否则将会报错LuaException: c# exception:System.InvalidCastException: This type must add to CSharpCallLua: System.Action）</p>
<p>6.重载方法
与C#一样，通过访问方法时不同的实参，即可进行重载函数的访问，例如</p>
<p>testSon:Log(3);
testSon:Log('qwe');
注意：XLua只一定程度上支持重载函数的调用，因为lua的类型远远不如C#的丰富，比如C#中的int，float，double等都对应lua的number。若C#有这些类型的重载，Lua则无法区分开来，只能调用到其中的一个（生成代码中排前面的那个）。</p>
<p>7.参数带默认值的方法，与可变参数方法
对于参数带默认值的方法，和C#一样，当所给的实参少于形参，则会用默认值补上。</p>
<p>对于可变参数，代码如下：</p>
<p>public class A {
    public static void MethodC(string s, params int[] arr) {
        foreach(int i in arr) {
            Debug.Log("MethodC----" + i);
        }
    }
}
对于的lua：</p>
<p>CS.MyExamples.A.MethodC('s',1,2,3);
8.枚举类型
枚举值就像枚举类型下的静态属性一样。假设我们C#有如下枚举</p>
<p>namespace MyExamples {
    public enum ETest {
        T1,
        T2,
        T3
    }
}
那么lua中使用CS.MyExamples.ETest.T1即可。</p>
<p>另外，如果枚举类加入到生成代码的话（即添加[LuaCallCSharp]标签），枚举类将支持__CastFrom方法，可以实现从一个整数或者字符串到枚举值的转换：</p>
<p>CS.MyExamples.A.MethodD(CS.MyExamples.ETest.T1);
CS.MyExamples.A.MethodD(CS.MyExamples.ETest.<strong>CastFrom(1));
CS.MyExamples.A.MethodD(CS.MyExamples.ETest.</strong>CastFrom('T3'));
9.delegate的使用（调用 + -）
C#的delegate调用：和调用普通的lua函数一样</p>
<p>例如，我们在C#定义了如下的delegate：</p>
<p>[LuaCallCSharp]
public class TestSon : Test {
    public delegate int IntDelegate(int a);
    public IntDelegate intDelegate = (a) =&gt; {
        Debug.Log("C#--intDelegate----a:" + a);
        return a;
    };
}
对应的Lua访问即：</p>
<p>testSon.intDelegate(10);
+操作符：对应C#的+操作符，把两个调用串成一个调用链，右操作数可以是同类型的C# delegate或者lua函数。</p>
<p>-操作符：和+相反，把一个delegate从调用链中移除。</p>
<p>ps：delegate属性可以用一个lua function来赋值。</p>
<p>local function lua_delegate(a)
    print('lua_delegate :', a)
end
testSon.intDelegate = lua_delegate + testSon.intDelegate --combine，这里演示的是C#delegate作为右值，左值也支持
testSon.intDelegate(100)
testSon.intDelegate = testSon.intDelegate - lua_delegate --remove
testSon.intDelegate(1000)
和第五条类似：需要将IntDelegate加入CSharpCallLua白名单。</p>
<p>10.event的使用
例如，我们定义了下面的event</p>
<p>public class TestSon : Test {
    public event IntDelegate intEvent;</p>
<pre><code class="lang-C#">public void ExeEvent(int a) {
    intEvent(a);
}
</code></pre>
<p>}
Lua中即可通过下面的方面去处理与访问</p>
<p>local function lua_eventCallback1(a)
    print('lua_eventCallback1 :', a)
end
local function lua_eventCallback2(a)
    print('lua_eventCallback2 :', a)
end
--增加事件回调
testSon:intEvent('+', lua_eventCallback1);
testSon:intEvent('+', lua_eventCallback2);
testSon:ExeEvent(100);
--移除事件回调
testSon:intEvent('-', lua_eventCallback1);
testSon:ExeEvent(1000);
testSon:intEvent('-', lua_eventCallback2);
11.C#的复杂类型和table的自动转换
对于一个有无参构造函数的C#复杂类型，在Lua中可以直接用一个table来代替，该table对应复杂类型的public字段有相应字段即可，支持函数参数传递，属性赋值等。（和C#调用Lua的时候类似）</p>
<p>例如我们有如下struct（class也是一样的）</p>
<p>public struct BoxA {
    int x;
    int y;
}</p>
<p>public struct BoxB {
    BoxA boxA;
    string name;
}
然后在C#中有如下方法，使用到该struct：</p>
<p>public static void MethodE(BoxB box) {
    Debug.Log("MethodE----name:" + box.name + "----x:" + box.boxA.x);
}
那么在lua中，我们就可以将如下进行调用：</p>
<p>CS.MyExamples.A.MethodE({boxA={x=1,y=2},name='box'});
12.获取类型（相当于C#的typeof）
例如，我们在lua中要获取一个类的Type信息，可以用typeof()，在添加组件的时候常常会用到，如下</p>
<p>go:AddComponent(typeof(CS.UnityEngine.ParticleSystem));
13.“强”转类型
lua中没有类型，所以不会有强类型语言的“强转”，但是有个有点像的东西：告诉XLua要用指定的生成代码去调用一个对象。比如有的时候第三方库对外暴露的时一个interface或者抽象类，实现类是隐藏的，这样我们无法对实现类进行代码的生成。该实现类将会被XLua识别为未生成代码而用反射来访问，如果这个调用是很频繁的话会很影响性能，这时我们可以把这个interface或者抽象类加到生成代码，然后指定用该生成代码来访问。</p>
<p>XLua提供了一个T cast(table, T)的API用于强转，把该table转成一个T指明的类型，可以是一个加了CSharpCallLua声明的interface，一个有默认构造函数的class或者struct，一个Dictionary，List等等。</p>
<p>例如我们在C#中定义了如下</p>
<p>//对外接口
[LuaCallCSharp]
public interface ICalc {
    int add(int a, int b);
}</p>
<p>//接口的内部实现，不对外
class CalcClass : ICalc {
    public int add(int a, int b) {
        return a + b;
    }</p>
<pre><code class="lang-c#">public int id = 100;
</code></pre>
<p>}
public class Test {
    //对外api 获取对应接口的实例
    public ICalc GetCalc() {
        return new CalcClass();
    }
}
我们在Lua中可以如下实现：</p>
<p>local calc = test:GetCalc();
print('calc------Add:',calc:Add(1,2));
上面这种方式就是前面所提到的映射方式，性能较差。所以我们可以加一步强转如下，用于提高性能：</p>
<p>cast(calc, typeof(CS.MyExamples.ICalc));
print('calc---case---add:',calc:Add(3,4));
--需要注意的是，强转interface之后，因为ICalc中并未定义id属性，所以强转之后去访问id的值（其实就没有这个字段了）为nil
assert(calc.id == nil);
--如同随便访问一个没有的字段qwer
assert(calc.qwer == nil);
ps: lua  assert() API，当参数为false或nil时，则会中断程序抛出异常。</p>
<p>14.扩展方法Extension methods
在C#定义好了扩展方法，在Lua中就可以和访问普通的成员方法一样使用，如下，为前文的Test类添加扩展方法。</p>
<p>注意：扩展方法必须加上[LuaCallCSharp]标签才能访问到。</p>
<p>[LuaCallCSharp]
public static class ExtraTest {
    public static void ExtraLog(this Test test, string s) {
        Debug.Log("ExtraTest----ExtraLog---" + s);
    }
}
然后在lua中，我们用之前的Test类的实例就可访问：</p>
<p>test:ExtraLog('122334');
15.泛化（模板）方法
Lua中不直接支持泛化，需要我们通过扩展方法进行封装，然后调用该扩展方法。例如，我们在C#有如下定义：</p>
<p>public class Test {
    public void GenericMethod<t>() {
        Debug.Log("GenericMethod&lt;" + typeof(T) + "&gt;");
    }
}
在lua中我们不能像C#那样直接用test.GenericMethod<string>()这样调用，需要我们手动封装一层，例如：</string></t></p>
<p>public static class ExtraTest {
    public static void GenericMethodWithString(this Test test) {
        test.GenericMethod<string>();
    }
}
然后在用lua去调用：</string></p>
<p>test:GenericMethodWithString();</p>
<h3 id="其他">其他</h3>
<p>​    如果不使用Lua原声的预编译机制, 也可以使用Xlua提供的签名工具来进行加密. 原理未通过公钥生成对应加密文件. 在本地解析时在进行一定规则进行解密. </p>
<p>​    </p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/User_Interface/fairy_gui.html" class="navigation navigation-prev " aria-label="Previous page: UI - FairlyGUI简介">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="https://gitbook.corp.sdo.com/seniorlcient/book/Architecture.html" class="navigation navigation-next " aria-label="Next page: 架构设计模式" style="margin-right: 17px;">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"脚本语言简介及应用","level":"1.19","depth":1,"next":{"title":"架构设计模式","level":"1.20","depth":1,"path":"book/Architecture.md","ref":"book/Architecture.md","articles":[]},"previous":{"title":"UI - FairlyGUI简介","level":"1.18","depth":1,"path":"book/User_Interface/fairy_gui.md","ref":"book/User_Interface/fairy_gui.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"book/Lua.md","mtime":"2019-05-05T03:07:42.976Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-11-22T03:40:09.001Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="./脚本语言简介及应用 · GitBook_files/gitbook.js.下载"></script>
    <script src="./脚本语言简介及应用 · GitBook_files/theme.js.下载"></script>
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/search-engine.js.下载"></script>
        
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/search.js.下载"></script>
        
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/lunr.min.js.下载"></script>
        
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/search-lunr.js.下载"></script>
        
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/buttons.js.下载"></script>
        
    
        
        <script src="./脚本语言简介及应用 · GitBook_files/fontsettings.js.下载"></script>
        
    

    


</body></html>